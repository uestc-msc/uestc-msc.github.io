<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[MSC 每周两题：去年题解 & 函数与结构体]]></title>
    <url>%2F2021%2F03%2F04%2F2020-programming-of-the-week-6-function-and-structure%2F</url>
    <content type="text"><![CDATA[《时隔一年，小灰灰终于想起了俱乐部的 GitHub 账号》 系列目录 MSC 每周两题：前言 &amp; 顺序结构 MSC 每周两题：上周题解 &amp; 分支结构 MSC 每周两题：上周题解 &amp; 循环结构 MSC 每周两题：上周题解 &amp; 数组 MSC 每周两题：上周题解 &amp; 字符串 MSC 每周两题：去年题解 &amp; 函数和结构体 MSC 每周两题：上周题解 &amp; 后记 P1914 小书童——凯撒密码众所周知，C 语言的字符串就是元素为 char 的数组，只是在输入输出时可以一次完成，不用像 int 数组一样需要 for 逐个读入。 这个题目要求把每个字符向后移动一位，超过 z 就重新从 a 开始计算。我们运用 for 逐个计算即可。这题好像没什么好说的 123456789101112131415#include&lt;stdio.h&gt;int main(){ int n; char str[50]; scanf("%d%s", &amp;n, str); for (int i = 0; str[i] != '\0'; i++) { str[i] += n; if (str[i] &gt; 'z') str[i] -= 26; } printf("%s", str);} 然后有两个测试点挂了 hhhhhh emmm 再读了一遍题目，似乎是没说 n 的范围，n 可能大于 26，导致结果超出范围了。 这里有两个解决办法：一是将里面的 if 改为 while，通过反复减就可以把结果控制在 a~z 范围内了；二是输入 n 后将 n 对 26 取模，这样就可以保证只用 if 减一次就可以在范围内。 第二遍提交又挂了（ 看了一下题解，发现由于 char 的范围是 -128~127，直接加可能导致越界，（'z' + 26 = 122 + 26 = 148）。可以先转成 int 再加。 第三次总算是过了 hhh 123456789101112131415161718// C++ 版本#include&lt;stdio.h&gt;int main(){ int n; char str[50]; scanf("%d%s", &amp;n, str); n %= 26; for (int i = 0; str[i] != '\0'; i++) { int temp = str[i] + n; if (temp &gt; 'z') temp -= 26; str[i] = temp; } printf("%s", str);} 最后有一个细节需要注意，C 语言求字符串长的 strlen 函数，每使用一次就会遍历一遍整个字符串，如果放在 for 里写成 for (int i = 0; i &lt; strlen(str); i++) 会导致重复计算，效率变低。有三种解决方案： 使用上面的方法，即使用 str[i] != 0 作为循环条件 提前存储长度 int len = strlen(str); for (int i = 0; i &lt; len; i++) 不使用 char[] 类型，而是使用 C++ string 类 三种方法任选一种即可。 以下是 Python3 版本： 123456789101112n = int(input())n %= 26string = input().strip()newstring = ''for c in string: temp = n + ord(c) if temp &gt; ord('z'): temp -= 26 newstring += chr(temp)print(newstring) P1597 语句解析语句解析这个题挺有意思，像是编译原理。当然，没必要用这么高深的知识。 我们只需要做三件事情： 读取语句，解析等号左边和右边的变量（或数字）； 将右边的变量（或数字）转换为值； 将值赋给左边的变量。 如何将字符 'a' 解析为变量 a 呢？在 C / C++ 中，由于变量都会被编译为 0x12345678 这样的内存，所以没办法方便地从字符串解析为变量名。 方法一最容易想到的，也是最麻烦的，就是用类似于下面的 if 判断： 1234567int value; if (ch == 'a') value = a;else if (ch == 'b') value = b;else if (ch == 'c') value = c; 这种方式好处就是很直观，坏处就是变量一多，就会很麻烦了，还不能自定义变量，只能靠题目提前告诉我们变量有哪些。 方法二注意到 'a' 'b' 'c' 是连续的 char，我们可以用一个数组 int variable[3] 模拟存储它们的值，需要存储/读取时，使用 variable[input-'a'] 即可。 123456789101112131415161718#include&lt;stdio.h&gt;int main(){ int variable[3] = { 0 }; char left_value, right_value; while (scanf("%c:=%c;", &amp;left_value, &amp;right_value) != EOF) { int value; if (right_value &gt;= 'a') value = variable[right_value - 'a']; else value = right_value - '0'; variable[left_value - 'a'] = value; } for (int i = 0; i &lt; 3; i++) printf("%d ", variable[i]);} 方法三方法三就超出了 C 语言的范围了，而是使用了 C++ 的 map。map 可以将值映射到值，我们如果把字符 a b c 分别映射到各自的变量对应的值，就完美解决了此题的需求。 当然，方法二也是一种映射，其映射关系是 variable[right_value - 'a']。硬说的话，其实方法一也是映射，只是说它的映射关系是一堆复杂的 if（分段函数的事，怎么能说复杂呢）。 不过 C++ 的 map 如果再配合 string，就能映射字符串（而不只是单个字符）。C 语言有很多替代方法，但不如 map 来得快。 12345678910111213141516171819#include&lt;stdio.h&gt;#include&lt;map&gt;int main(){ std::map&lt;char, int&gt;variable; char left_value, right_value; while (scanf("%c:=%c;", &amp;left_value, &amp;right_value) != EOF) { int value; if (right_value &gt;= 'a') value = variable[right_value]; else value = right_value - '0'; variable[left_value] = value; } for (char i = 'a'; i &lt;= 'c'; i++) printf("%d ", variable[i]);} PythonPython 由于自带了 dict 类型，类似于 C++ map，所以这类问题很方便。就是解析语句时没有 C 语言 scanf 那么方便。 1234567891011statements = input().strip().strip(';').split(';')variable = {'a': '0', 'b': '0', 'c': '0'}for statement in statements: left_value, right_value = statement.split(':=') if right_value &gt;= 'a': variable[left_value] = variable[right_value] else: variable[left_value] = right_valueprint(variable['a'], variable['b'], variable['c']) 本周题单：函数和结构体本周的题单，也是最后一个专题，是函数与结构体。 下面的题目不多，但挺有意思。 函数里面，最复杂，包含知识点最多的，就是递归了。所以我们挑一个比较典型的递归来做：P5727 【深基5.例3】冰雹猜想 还有就是我们之前留的最后一个坑：判断一个日期是否合法。请同学们封装成一个函数（如果需要的话，可以创建更多的函数），并自行测试情况正确与否。 下周末将会针对这两个题开一次沙龙讲解，之后会放出题解~ document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });]]></content>
      <categories>
        <category>C++</category>
        <category>MSC 每周两题</category>
      </categories>
      <tags>
        <tag>小灰晖</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MSC 每周两题：上周题解 & 字符串]]></title>
    <url>%2F2020%2F12%2F25%2F2020-programming-of-the-week-5-string%2F</url>
    <content type="text"><![CDATA[数组部分的题解！ 系列目录 MSC 每周两题：前言 &amp; 顺序结构 MSC 每周两题：上周题解 &amp; 分支结构 MSC 每周两题：上周题解 &amp; 循环结构 MSC 每周两题：上周题解 &amp; 数组 MSC 每周两题：上周题解 &amp; 字符串 MSC 每周两题：去年题解 &amp; 函数和结构体 MSC 每周两题：上周题解 &amp; 后记 P5728 【深基5.例5】旗鼓相当的对手P5728 【深基5.例5】旗鼓相当的对手 一看就是老炉石玩家了 这题比较基础，可以练习一下数组的语法。就不多讲了。 具体的代码上，可以使用二维数组存所有的成绩，也可以使用三个一维数组分别存语文、数学和英语成绩（也可以再用第四个一位数组存总成绩）。 C++ 采用四个一维数组进行实现： 1234567891011121314151617181920212223242526272829#include&lt;stdio.h&gt;#include&lt;math.h&gt;int main(){ int chinese[1000], math[1000], english[1000], total[1000]; int n, ans = 0; scanf("%d", &amp;n); for (int i = 0; i &lt; n; i++) { scanf("%d%d%d", &amp;chinese[i], &amp;math[i], &amp;english[i]); total[i] = chinese[i] + math[i] + english[i]; } for (int i = 0; i &lt; n; i++) { for (int j = i + 1; j &lt; n; j++) { if (abs(chinese[i] - chinese[j]) &lt;= 5 &amp;&amp; abs(math[i] - math[j]) &lt;= 5 &amp;&amp; abs(english[i] - english[j]) &lt;= 5 &amp;&amp; abs(total[i] - total[j]) &lt;= 10) ans++; } } printf("%d", ans);} Python 使用二维数组进行实现： 1234567891011121314151617n = int(input())scores = []for i in range(n): score = list(map(int, input().split())) scores.append(score)ans = 0for i in range(n): for j in range(i+1, n): if abs(scores[i][0] - scores[j][0]) &lt;= 5 \ and abs(scores[i][1] - scores[j][1]) &lt;= 5 \ and abs(scores[i][2] - scores[j][2]) &lt;= 5 \ and abs(sum(scores[i]) - sum(scores[j])) &lt;= 10: ans += 1print(ans) 这次还新加入了 Go 语言，使用三个一维数组实现： 123456789101112131415161718192021222324252627282930313233343536package mainimport ( "fmt")func abs(x int) int { if x &lt; 0 { return -x } else { return x }}func main() { n, ans := 0, 0 fmt.Scanln(&amp;n) chinese, math, english := make([]int, n), make([]int, n), make([]int, n) for i := 0; i &lt; n; i++ { fmt.Scanln(&amp;chinese[i], &amp;math[i], &amp;english[i]) } for i := 0; i &lt; n; i++ { for j := i+1; j &lt; n; j++ { if abs(chinese[i] - chinese[j]) &lt;= 5 &amp;&amp; abs(math[i] - math[j]) &lt;= 5 &amp;&amp; abs(english[i] - english[j]) &lt;= 5 &amp;&amp; abs(chinese[i] + math[i] + english[i] - chinese[j] - math[j] - english[j]) &lt;= 10 { ans++ } } } fmt.Println(ans)} P1789 【Mc生存】插火把P1789 【Mc生存】插火把 一看就是老 MC 玩家了 也是非常基础的一个题，按照题目说的，使用一个二维数组模拟地图。先假设每个格子都可能出现怪物 (true)，然后对每个火把和萤石，将其照亮的区域标记为 false，最后数一遍地图上还有多少个 true 即可。 处理萤石比较简单，因为萤石照亮的范围是： \left\{\begin{matrix} x-2 \leq x_0 \leq x+2 \\ y-2 \leq y_0 \leq y+2 \end{matrix}\right.但是火把的范围比较麻烦，它是一个菱形。我们可以这样定义：设 $dx = x-x_0, dy = y-y_0$，则有 |dx|+|dy| \leq 2最后还需要注意，可能出现火把（萤石）照到地图以外的地方，所以记得判定是否越界。 C 语言： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758#include&lt;stdio.h&gt;int main(){ bool monster[100][100]; int n, fire, stone; scanf("%d%d%d", &amp;n, &amp;fire, &amp;stone); for (int i = 0; i &lt; n; i++) for (int j = 0; j &lt; n; j++) monster[i][j] = true; for (int i = 0; i &lt; fire; i++) // 统计火把 { int x0, y0; scanf("%d%d", &amp;x0, &amp;y0); x0--, y0--; // 我们定义的地图数组下标从 0 开始，题目从 1 开始，所以要把题目的输入减 1 for (int dx = 0; dx &lt;= 2; dx++) { for (int dy = 0; dy &lt;= 2 - dx; dy++) { if (x0 - dx &gt;= 0 &amp;&amp; x0 - dx &lt; n &amp;&amp; y0 - dy &gt;= 0 &amp;&amp; y0 - dy &lt; n) // 判定越界 monster[x0 - dx][y0 - dy] = false; if (x0 + dx &gt;= 0 &amp;&amp; x0 + dx &lt; n &amp;&amp; y0 - dy &gt;= 0 &amp;&amp; y0 - dy &lt; n) // 判定越界 monster[x0 + dx][y0 - dy] = false; if (x0 - dx &gt;= 0 &amp;&amp; x0 - dx &lt; n &amp;&amp; y0 + dy &gt;= 0 &amp;&amp; y0 + dy &lt; n) // 判定越界 monster[x0 - dx][y0 + dy] = false; if (x0 + dx &gt;= 0 &amp;&amp; x0 + dx &lt; n &amp;&amp; y0 + dy &gt;= 0 &amp;&amp; y0 + dy &lt; n) // 判定越界 monster[x0 + dx][y0 + dy] = false; } } } for (int i = 0; i &lt; stone; i++) // 统计萤石 { int x0, y0; scanf("%d%d", &amp;x0, &amp;y0); x0--, y0--; for (int x = x0 - 2; x &lt;= x0 + 2; x++) { if (x &lt; 0 || x &gt;= n) // 判定越界 continue; for (int y = y0 - 2; y &lt;= y0 + 2; y++) { if (y &lt; 0 || y &gt;= n) continue; monster[x][y] = false; } } } int ans = 0; // 统计怪物总数 for (int x = 0; x &lt; n; x++) for (int y = 0; y &lt; n; y++) if (monster[x][y]) ans++; printf("%d", ans);} 注意到 21 行至 28 行都是结构重复的代码，只是处理的变量有点不同。因此我们可以把重复的一个小过程独立为函数（但这是下周的内容，所以不做要求）。同时我们还需要将 monster[][] 和 n 的定义放到 main 函数以外（相关知识：函数作用域）。 题外话，如果不想把 monster 和 n 的定义放到 main 外呢？可以把这两个作为函数的参数（但是二维数组一般不推荐作为函数参数），或者使用 lambda 表达式在 main 函数内定义我们上面提到的函数。这里涉及的知识又有不少了，甚至 lambda 表达式超出了 C 语言的范围，因此我们略过，有兴趣的同学可以自己了解。 运用函数的 C 语言版本： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758#include&lt;stdio.h&gt;#include&lt;math.h&gt;bool monster[100][100];int n, fire, stone;int lighten(int x, int y){ if (x &gt;= 0 &amp;&amp; x &lt; n &amp;&amp; y &gt;= 0 &amp;&amp; y &lt; n) // 判定越界 monster[x][y] = false;}int main(){ scanf("%d%d%d", &amp;n, &amp;fire, &amp;stone); for (int i = 0; i &lt; n; i++) for (int j = 0; j &lt; n; j++) monster[i][j] = true; for (int i = 0; i &lt; fire; i++) // 统计火把 { int x0, y0; scanf("%d%d", &amp;x0, &amp;y0); x0--, y0--; // 我们定义的地图数组下标从 0 开始，题目从 1 开始，所以要把题目的输入减 1 for (int dx = 0; dx &lt;= 2; dx++) { for (int dy = 0; dy &lt;= 2 - dx; dy++) { lighten(x0 + dx, y0 - dy); lighten(x0 - dx, y0 + dy); lighten(x0 + dx, y0 + dy); lighten(x0 - dx, y0 - dy); } } } for (int i = 0; i &lt; stone; i++) // 统计萤石 { int x0, y0; scanf("%d%d", &amp;x0, &amp;y0); x0--, y0--; for (int x = x0 - 2; x &lt;= x0 + 2; x++) { for (int y = y0 - 2; y &lt;= y0 + 2; y++) { lighten(x, y); } } } int ans = 0; // 统计怪物总数 for (int x = 0; x &lt; n; x++) for (int y = 0; y &lt; n; y++) if (monster[x][y]) ans++; printf("%d", ans);} Python 版本直接给出利用函数的版本： 1234567891011121314151617181920212223242526272829def lighten(x: int, y: int): if 0 &lt;= x &lt; n and 0 &lt;= y &lt; n: monster[x][y] = Falsen, fire, stone = map(int, input().split())monster = [[True] * n for i in range(n)] # 运用列表生成式初始化二维数组for i in range(fire): # 处理萤火 x0, y0 = map(int, input().split()) x0 -= 1 y0 -= 1 for dx in range(0, 3): for dy in range(0, 3 - dx): lighten(x0-dx, y0-dy) lighten(x0+dx, y0-dy) lighten(x0-dx, y0+dy) lighten(x0+dx, y0+dy)for i in range(stone): # 处理萤火 x0, y0 = map(int, input().split()) x0 -= 1 y0 -= 1 for dx in range(-2, 3): for dy in range(-2, 3): lighten(x0+dx, y0+dy)s = sum(map(sum, monster)) # 二维数组求和print(s) Go 版本： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061package mainimport ( "fmt")var n intvar monster [100][100]boolfunc lighten(x int, y int) { if x &gt;= 0 &amp;&amp; x &lt; n &amp;&amp; y &gt;= 0 &amp;&amp; y &lt; n { monster[x][y] = false }}func main() { fire, stone, ans := 0, 0,0 fmt.Scanln(&amp;n, &amp;fire, &amp;stone) for i := 0; i &lt; n; i++ { for j := 0; j &lt; n; j++ { monster[i][j] = true } } for i := 0; i &lt; fire; i++ { // 处理火把 var x, y int fmt.Scanln(&amp;x, &amp;y) x-- y-- for dx := 0; dx &lt;= 2; dx++ { for dy := 0; dy &lt;= 2 - dx; dy++ { lighten(x-dx, y-dy) lighten(x+dx, y-dy) lighten(x-dx, y+dy) lighten(x+dx, y+dy) } } } for i := 0; i &lt; stone; i++ { // 处理萤石 var x, y int fmt.Scanln(&amp;x, &amp;y) x-- y-- for dx := -2; dx &lt;= 2; dx++ { for dy := -2; dy &lt;= 2; dy++ { lighten(x+dx, y+dy) } } } for i := 0; i &lt; n; i++ { for j := 0; j &lt; n; j++ { if monster[i][j] { ans++ } } } fmt.Println(ans)} P2615 神奇的幻方P2615 神奇的幻方 题目讲的是构造幻方的一个套路。按照题意写就行啦。这里只给出 C++ 的版本： 12345678910111213141516171819202122232425262728293031323334353637383940#include&lt;stdio.h&gt;int main(){ int square[40][40]; int n, i, j; // i 表示行，j 表示列，下标从 1 开始 scanf("%d", &amp;n); i = 1, j = n / 2 + 1; for (int sum = 1; sum &lt;= n * n; sum++) { square[i][j] = sum; if (sum % n == 0) { i++; if (i == n + 1) i = 1; } else { i--; j++; } if (i == 0) i = n; if (j == n + 1) j = 1; } for (int i = 1; i &lt;= n; i++) { for (int j = 1; j &lt;= n; j++) printf("%d ", square[i][j]); printf("\n"); } return 0;} P5716 【深基3.例9】月份天数P5716 【深基3.例9】月份天数 使用闰年判断的代码，我们可以判断某年 2 月的天数。剩下的月份我们只需要打一份表，将十一个月的天数保存在一个数组中，根据不同输入，输出对应的数字即可。 C 语言版本： 12345678910111213141516171819#include&lt;stdio.h&gt;int main(){ const int mdays[] = { -1, 31, -1, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31 }; // 十二个月每月的天数 int year, month; scanf("%d%d", &amp;year, &amp;month); if (month != 2) printf("%d", mdays[month]); else if (year % 4 != 0) printf("28"); else if (year % 100 != 0) printf("29"); else if (year % 400 != 0) printf("28"); else printf("29"); return 0;} Python 版本： 123456789101112mdays = [-1, 31, -1, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31]year, month = map(int, input().split())if month != 2: print(mdays[month])elif year % 4 != 0: print(28)elif year % 100 != 0: print(29)elif year % 400 != 0: print(28)else: print(29) Go 版本： 1234567891011121314151617181920package mainimport "fmt"func main() { var year, month int mdays := []int{-1, 31, -1, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31} fmt.Scanln(&amp;year, &amp;month) if month != 2 { fmt.Println(mdays[month]) } else if year%4 != 0 { fmt.Println(28) } else if year%100 != 0 { fmt.Println(29) } else if year%400 != 0 { fmt.Println(28) } else { fmt.Println(29) }} 本周题单：字符串这周的题单是字符串。这周的题单 15 题中，必做的为 P1914 小书童——凯撒密码 和 P1597 语句解析。 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });]]></content>
      <categories>
        <category>C++</category>
        <category>MSC 每周两题</category>
      </categories>
      <tags>
        <tag>小灰晖</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MSC 每周两题：上周题解 & 数组]]></title>
    <url>%2F2020%2F12%2F15%2F2020-programming-of-the-week-4-array%2F</url>
    <content type="text"><![CDATA[说周五发这篇博客，然后就咕了一个多星期 hhhh 俱乐部的鸽子本性。 不过，本期题解的线下沙龙的录屏已经投到了 B 站（就是麦克风效果有点不行）： 系列目录 MSC 每周两题：前言 &amp; 顺序结构 MSC 每周两题：上周题解 &amp; 分支结构 MSC 每周两题：上周题解 &amp; 循环结构 MSC 每周两题：上周题解 &amp; 数组 MSC 每周两题：上周题解 &amp; 字符串 MSC 每周两题：去年题解 &amp; 函数和结构体 MSC 每周两题：上周题解 &amp; 后记 P5719 【深基4.例3】分类平均P5719 【深基4.例3】分类平均 方法一最简单的做法就是把 $1$ 到 $n$ 的数全部遍历一遍，然后使用一个 if 对数分类，统计数的总和以及总数，最后求一个平均数即可。 1234567891011121314151617181920212223#include&lt;stdio.h&gt;int main(){ int n, k; double a_sum = 0, b_sum = 0, a_n = 0, b_n = 0; scanf("%d%d", &amp;n, &amp;k); for (int i = 1; i &lt;= n; i++) { if (i % k == 0) { a_sum += i; a_n++; } else { b_sum += i; b_n++; } } printf("%.1f %.1f", a_sum / a_n, b_sum / b_n); return 0;} 应同学要求，这次加上了 Python 3 的代码。 使用 Python，可以使用 filter 函数将数组直接分为能被 $k$ 整除，以及不能被 $k$ 整除的部分，而不用写 for 语句。 1234567n, k = map(int, input().split())numbers = range(1, n+1)numbers_a = list(filter(lambda x: x % k == 0, numbers))numbers_b = list(filter(lambda x: x % k != 0, numbers))average_a = sum(numbers_a)/len(numbers_a)average_b = sum(numbers_b)/len(numbers_b)print("%.1f %.1f" % (average_a, average_b)) 方法二除了循环以外，能不能直接根据 n 和 k 直接计算得出结果呢？这道题有很强的数学性质，于是可以尝试往这方面想想。 设两个集合分别为 $S_A$ 和 $S_B$。显然有： \sum_{x \in S_A} x + \sum_{y \in S_B} y = \frac{1}{2}n(n+1)|S_A| + |S_B| = n注意到 $S_A$ 是“前 $n$ 个数中能被 $k$ 整除的数组成的集合”，所以不难推出集合 $S_A$ 中共有 $\lfloor\frac{n}{k}\rfloor$ 个元素。（不会推导的同学也可以举 $n=5, k=2$ 这样的例子验证） 而 $S_A$ 中的元素又构成了首项、公差均为 $k$ 的等差数列，其个数也可以求出（如上）。 用总的个数与元素和分别减去 $S_A$ 的个数和元素和，就可以得到 $S_B$ 的个数以及元素和。最后分别求 $S_A$ 和 $S_B$ 的平均数即可。 下面是 C 和 Python 3 的实现。 123456789101112131415#include&lt;stdio.h&gt;int main(){ int n, k; double a_sum = 0, b_sum = 0, a_n = 0, b_n = 0, sum = 0; scanf("%d%d", &amp;n, &amp;k); sum = (1 + n) * n / 2; a_n = n / k; a_sum = (k + k * a_n) * a_n / 2; b_n = n - a_n; b_sum = sum - a_sum; printf("%.1f %.1f", a_sum / a_n, b_sum / b_n); return 0;} 1234567n, k = map(int, input().split())sum = (1 + n) * n / 2a_n = n // ka_sum = (k + k * a_n) * a_n / 2b_n = n - a_nb_sum = sum - a_sumprint("%.1f %.1f" % (a_sum / a_n, b_sum / b_n)) P5723 【深基4.例13】质数口袋P5723 【深基4.例13】质数口袋 方法一题目本质是在求从 2 开始的所有质数，直至满足其和大于 $L$。所以本题的三个方法均围绕如何求质数进行。 最朴素的方法就是根据质数的定义： 质数（Prime number），又称素数，指在大于1的自然数中，除了1和该数自身外，无法被其他自然数整除的数（也可定义为只有1与该数本身两个正因数的数）。 根据定义，对于大于1的自然数 $i$，如果验证 $2\sim i-1$ 均不能整除 $i$，那么 $i$ 一定是质数。 但是，一定要判定 $2\sim i-1$ 吗？ 一种优化，是只判定 $2\sim \sqrt{i}$ 之间的整数。因为一个合数 $i$ 必然会有一个因数小于 $\sqrt{i}$（想想，这是为什么？）。 下面的 C 和 Python 代码就采用了这种优化。 123456789101112131415161718192021222324252627282930#include&lt;stdio.h&gt;#include&lt;math.h&gt;int main(){ int L; scanf_s("%d", &amp;L); int sum = 0, n = 0; for (int i = 2; sum + i &lt;= L; i++) { bool is_prime = true; int sqrt_i = sqrt(i); // 注意不要把 sqrt(i) 的计算过程写到 for 的判定条件中 // 在不考虑编译器优化的情况下，这种写法会导致每次判定 j &lt;= sqrt(i) 时都会重新计算 sqrt(i) for (int j = 2; j &lt;= sqrt_i; j++) { if (i % j == 0) { is_prime = false; break; } } if (is_prime) { sum += i; n++; printf("%d\n", i); } } printf("%d", n);} 1234567891011121314151617from math import sqrtL=int(input())sum, n = 0, 0for i in range(2, L): if sum+i &gt; L: break is_prime = True for j in range(2, int(sqrt(i))+1): if i % j == 0: is_prime = False break if is_prime: sum += i n += 1 print(i)print(n) 对这种方法更进一步的优化，是只判定 $2\sim \sqrt{i}$ 之间的质数。因为一个合数 $i$ 必然会有一个质因数小于 $\sqrt{i}$。 不过，这样就要求将前面计算出的质数存到数组中，需要额外的数组空间。 方法二方法二源于埃拉托斯特尼筛法。其算法思想是，假设所有数都是质数，第一步先从 4 开始把 2 的倍数筛掉（因为都是和数），下一步筛掉 3 的倍数，然后筛掉 5 的倍数…… 由于算法很著名，网上有不少现成的、形象易懂的埃氏筛算法的讲解博客，因此这里不进行更多展开。感兴趣的同学可以自行搜索并进行学习。 下面是 C 和 Python 3 的实现。 123456789101112131415161718192021222324#include&lt;stdio.h&gt;#include&lt;math.h&gt;const int max_size = 1e6 + 5;int main(){ // 为方便，这里使用 is_not_prime 并设初值为 0，代替算法中的 is_prime 初值为 1 bool is_not_prime[max_size] = { 0 }; int L; scanf_s("%d", &amp;L); int sum = 0, n = 0; for (int i = 2; sum + i &lt;= L; i++) { if (is_not_prime[i]) continue; for (int j = i * i; i * j &lt;= L; j += i) is_not_prime[j] = 1; sum += i; n++; printf("%d\n", i); } printf("%d", n);} 123456789101112131415MAX_SIZE = 100005is_not_prime = [False] * MAX_SIZEL=int(input())sum, n = 0, 0for i in range(2, L): if sum+i &gt; L: break if is_not_prime[i]: continue for j in range(i*i, L+1, i): is_not_prime[j] = True sum += i n += 1 print(i)print(n) 除此之外，埃氏筛法还有线性筛、奇数筛等优化，学有余力的同学可以自行搜索了解。 方法三还有一种方法，这种方法是为了单纯为了把程序运行速度提高到极致才产生的方法：使用方法一或方法二的算法生成足够用的质数表，然后将质数表复制到代码里直接使用！ 这种技巧被称为“打表”。 打表，是一个信息学专用术语，意指对一些题目，通过打表技巧获得一个有序表或常量表，来执行程序某一部分，优化时间复杂度。这种算法也可用于在对某种题目没有最优解法时，用来得到分数的一种策略。 以下是我们得到了质数表的前提下的 C 和 Python 3 代码。 12345678910111213141516171819#include&lt;stdio.h&gt;#include&lt;math.h&gt;int prime[] = { 2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97, 101, 103, 107, 109, 113, 127, 131, 137, 139, 149, 151, 157, 163, 167, 173, 179, 181, 191, 193, 197, 199, 211, 223, 227, 229, 233, 239, 241, 251, 257, 263, 269, 271, 277, 281, 283, 293, 307, 311, 313, 317, 331, 337, 347, 349, 353, 359, 367, 373, 379, 383, 389, 397, 401, 409, 419, 421, 431, 433, 439, 443, 449, 457, 461, 463, 467, 479, 487, 491, 499, 503, 509, 521, 523, 541, 547, 557, 563, 569, 571, 577, 587, 593, 599, 601, 607, 613, 617, 619, 631, 641, 643, 647, 653, 659, 661, 673, 677, 683, 691, 701, 709, 719, 727, 733, 739, 743, 751, 757, 761, 769, 773, 787, 797, 809, 811, 821, 823, 827, 829, 839, 853, 857, 859, 863, 877, 881, 883, 887, 907, 911, 919, 929, 937, 941, 947, 953, 967, 971, 977, 983, 991, 997, 1009, 1013, 1019, 1021, 1031, 1033, 1039, 1049, 1051, 1061, 1063, 1069, 1087, 1091, 1093, 1097, 1103, 1109, 1117, 1123, 1129, 1151, 10000};// 最后一个 10000 是防止遍历数组的时候越界int main(){ int L; scanf_s("%d", &amp;L); int sum = 0, n = 0; for (int i = 0; sum + prime[i] &lt;= L; i++) { sum += prime[i]; n++; printf("%d\n", prime[i]); } printf("%d", n);} 1234567891011prime = [ 2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97, 101, 103, 107, 109, 113, 127, 131, 137, 139, 149, 151, 157, 163, 167, 173, 179, 181, 191, 193, 197, 199, 211, 223, 227, 229, 233, 239, 241, 251, 257, 263, 269, 271, 277, 281, 283, 293, 307, 311, 313, 317, 331, 337, 347, 349, 353, 359, 367, 373, 379, 383, 389, 397, 401, 409, 419, 421, 431, 433, 439, 443, 449, 457, 461, 463, 467, 479, 487, 491, 499, 503, 509, 521, 523, 541, 547, 557, 563, 569, 571, 577, 587, 593, 599, 601, 607, 613, 617, 619, 631, 641, 643, 647, 653, 659, 661, 673, 677, 683, 691, 701, 709, 719, 727, 733, 739, 743, 751, 757, 761, 769, 773, 787, 797, 809, 811, 821, 823, 827, 829, 839, 853, 857, 859, 863, 877, 881, 883, 887, 907, 911, 919, 929, 937, 941, 947, 953, 967, 971, 977, 983, 991, 997, 1009, 1013, 1019, 1021, 1031, 1033, 1039, 1049, 1051, 1061, 1063, 1069, 1087, 1091, 1093, 1097, 1103, 1109, 1117, 1123, 1129, 1151, 10000]L=int(input())sum, n = 0, 0for i in prime: if sum+i &gt; L: break sum += i n += 1 print(i)print(n) 将代码上传到 GitHub上上周我们开了沙龙讲解如何配置 WSL 和 Git。这里有博客记录：WSL(Ubuntu)、Git 配置及简单使用。 我们希望同学能将自己在洛谷提交的代码也提交到 Git 仓库：uestc-msc/2020-members。提交时，请 fork 原仓库到自己账号下，在自己账号下的仓库完成提交，然后向俱乐部仓库 Pull Request。 尚不会使用 Git 的同学，可以参考上面的博客，也可以在 QQ 群里提问。 本周题单：数组这周的题单是数组。这周的题单 20 题中，必做的为 P5728 【深基5.例5】旗鼓相当的对手 和 P1789 【Mc生存】插火把，还有 P2615 神奇的幻方。 除了上面的题以外，我们还需要填一个坑，就是基于之前分支结构中的 P5711 【深基3.例3】闰年判断 的 P5716 【深基3.例9】月份天数。各位可以基于之前的代码加以完善，然后完成此题。 本次题目的题解将于下周五 (2020-12-25) 给出，敬请期待~ document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });]]></content>
      <categories>
        <category>C++</category>
        <category>MSC 每周两题</category>
      </categories>
      <tags>
        <tag>小灰晖</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MSC 每周两题：上周题解 & 循环结构]]></title>
    <url>%2F2020%2F11%2F27%2F2020-programming-of-the-week-3-loop%2F</url>
    <content type="text"><![CDATA[分支结构的题解！ 系列目录 MSC 每周两题：前言 &amp; 顺序结构 MSC 每周两题：上周题解 &amp; 分支结构 MSC 每周两题：上周题解 &amp; 循环结构 MSC 每周两题：上周题解 &amp; 数组 MSC 每周两题：上周题解 &amp; 字符串 MSC 每周两题：去年题解 &amp; 函数和结构体 MSC 每周两题：上周题解 &amp; 后记 P5712 【深基3.例4】ApplesP5712 【深基3.例4】Apples。最容易想到的方法就是用 if 分为两种情况：加 s 和不加 s 的，然后分别输出。 1234567891011#include&lt;stdio.h&gt;int main(){ int n; scanf("%d", &amp;n); if (n &lt;= 1) printf("Today, I ate %d apple.", n); else printf("Today, I ate %d apples.", n);} 如果你学过字符串和三目运算符，这道题还有另一个简洁的写法： 12345678#include&lt;stdio.h&gt;int main(){ int n; scanf("%d", &amp;n); printf("Today, I ate %d apple%s.", n, n &lt;= 1 ? "" : "s");} 如果没有学过的话，你可以三目运算符认为是 if 的简化版：这个表达式的值会根据 ? 前面的条件（即 n &lt;= 1）进行选择： 如果 n &lt;= 1，表达式的值为 : 前的值（即 ""） 如果 n &gt; 2，表达式的值为 : 后的值（即 "s"） 程序经过判断后计算出了表达式的值，然后就可以在输出 apple 后输出一个 s，或什么都不输出。 P5711 【深基3.例3】闰年判断P5711 【深基3.例3】闰年判断，只需要注意什么情况是闰年就可以了。不过，要判断的情况有点多，写起来有点混乱啊…… 一种思路，就是把所有互斥（互斥：以下情况最多只会发生一个，不会同时发生两个或更多）的情况独立地写出来： 若年份不是 4 的倍数，则不是闰年； 若年份是 4 的倍数，同时不是 100 的倍数，则是闰年； 若年份是 100 的倍数，同时不是 400 的倍数，则不是闰年； 若年份是 400 的倍数，则是闰年。 然后一一单独判断这些情况即可。 12345678910111213141516#include&lt;stdio.h&gt;int main(){ int year; scanf("%d", &amp;year); if (year % 4 != 0) printf("0"); else if (year % 4 == 0 &amp;&amp; year % 100 != 0) printf("1"); else if (year % 100 == 0 &amp;&amp; year % 400 != 0) printf("0"); else if (year % 400 == 0) printf("1"); return 0;} 顺便一提，上面的这种 if ... else if ... else if ... else if ...，我们在分析代码含义的时候可以认为他是链式结构（即，如果你想在后面再加其他情况的判断，在后面追加 else if ... 即可，像是在一条链子后面加上了一个相同的环形成了更长的链子，而不需要嵌套）。 但是，由于 C 语言 if 后只会执行一个语句（或语句块），编译器会以嵌套的形式理解这段代码： 1234567891011121314151617if (year % 4 != 0) printf("0");else{ if (year % 4 == 0 &amp;&amp; year % 100 != 0) printf("1"); else { if (year % 100 == 0 &amp;&amp; year % 400 != 0) printf("0"); else { if (year % 400 == 0) printf("1"); } }} 编译器会认为，每个 else 语句后面又跟了一个完整的 if else。很明显，这种嵌套的方式非常不美观。因此，编写自己的代码或是理解别人的代码时，我们按照链式理解就可以了。 另一种思路就是把所有年份从大类分到小类，然后依次判断： 先把所有年份分为“能被 4 整除”和“不能被 4 整除”，后面一种情况可以判断为非闰年 把“能被 4 整除”的再分为“能被 100 整除”和“不能被 100 整除”，后面一种情况可以判断为闰年 再把“能被 100 整除”的再分为“能被 400 整除”和“不能被 400 整除”，两种情况均可判断 这里就会写出嵌套的 if else： 123456789101112131415161718192021222324#include&lt;stdio.h&gt;int main(){ int year; scanf("%d", &amp;year); if (year % 4 != 0) printf("0"); else { //能被 4 整除 if (year % 100 != 0) printf("1"); else { // 能被 100 整除 if (year % 400 != 0) printf("0"); else // 能被 400 整除 { printf("1"); } } } return 0;} 我们尝试将其改写为为链式的 if else： 12345678910111213141516#include&lt;stdio.h&gt;int main(){ int year; scanf("%d", &amp;year); if (year % 4 != 0) printf("0"); else if (year % 100 != 0) printf("1"); else if (year % 400 != 0) printf("0"); else // 能被 400 整除 printf("1"); return 0;} 简洁多了，甚至比第一段代码还简洁。不过个人认为，第一种把所有互斥情况列出来的方法，不容易出错；第二种从大类分到小类的方法，需要仔细琢磨。 学会了闰年判断，能否判断一个年月有多少天呢？这个坑放到数组专题来填（这是第几次挖坑了）。 本周题单：循环结构这周的题单是循环结构。这周的题单 13 题中，必做的为P5719 【深基4.例3】分类平均和P5723 【深基4.例13】质数口袋。 除此之外，还有就是前面挖的坑：打印 ASCII 表。这里你只需要保证可见字符（字母数字、标点符号等）输出正常，某些不可见的字符的格式不做要求。 本周的“质数口袋”题目解法繁多，所以可能会有线下沙龙讲解。但是线上博客依旧是下周五晚八点之前更新，不见不散~ document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });]]></content>
      <categories>
        <category>C++</category>
        <category>MSC 每周两题</category>
      </categories>
      <tags>
        <tag>小灰晖</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MSC 每周两题：上周题解 & 分支结构]]></title>
    <url>%2F2020%2F11%2F20%2F2020-programming-of-the-week-2-branch%2F</url>
    <content type="text"><![CDATA[首先是上次顺序结构的题解！ 单纯只出顺序结构相关的题，是不会像分支、循环、函数、结构体等后面的专题一样把 C 玩出花来。所以也就出一些基础一点的题加一点数学题（如果你想体验亿点数学题的话，可以看看P2433 【深基1-2】小学数学 N 合一）。 系列目录 MSC 每周两题：前言 &amp; 顺序结构 MSC 每周两题：上周题解 &amp; 分支结构 MSC 每周两题：上周题解 &amp; 循环结构 MSC 每周两题：上周题解 &amp; 数组 MSC 每周两题：上周题解 &amp; 字符串 MSC 每周两题：去年题解 &amp; 函数和结构体 MSC 每周两题：上周题解 &amp; 后记 P5704 【深基2.例6】字母转换先看 P5704 【深基2.例6】字母转换。 题目要求将小写字母转换为大写字母。 C 语言中，字符 char 是按照 ASCII 码存储的，其中 ASCII 表可以百度到，也可以使用你手上的 C 语言编译器自己做一张表（但是这需要循环结构的知识，这里就先挖一个坑；如果你已经学会了循环结构，你可以提前做一张表）。 从表中可以注意到，大小写字母的 ASCII 码是一一对应的，同一个字母的大小写相差 32。于是，我们对字符变量进行运算：输出字符 = 输入字符 - 32 即可完成此题。 如果恰巧忘了 32 这个常量值，我们也可以让计算机自行计算出 'a' - 'A' 的值。如下面的代码： 123456789#include&lt;stdio.h&gt;int main(){ char ch; scanf("%c", &amp;ch); ch = ch - 'a' + 'A'; printf("%c", ch);} 也就是说，我们并不一定要死记 ASCII 码间的对应关系，而是让电脑自己去运算，这样代码的可读性也会更高。（如，将数字字符转为其数字值时，我更喜欢 num = ch - '0'; 而不是 num = ch - 48;） P5708 【深基2.习2】三角形面积另外一题是 P5708 【深基2.习2】三角形面积。这道题公式都你糊脸上了，直接抄上去就行了程序员的事，能叫抄公式吗？那叫代码复用，我们要讲码德。 12345678910111213#include&lt;stdio.h&gt;#include&lt;math.h&gt;int main(){ // float a, b, c, p, area; double a, b, c, p, area; scanf("%lf%lf%lf", &amp;a, &amp;b, &amp;c); p = (a + b + c) / 2; area = sqrt(p * (p-a) * (p-b) * (p-c)); printf("%.1f", area); return 0;} 这道题如果使用 float 类型运算，最后一个测试点会 Wrong Answer，使用 double 才能全部通过。最后一个测试点的输入为 888.88 888.88 888.88，使用 float 的输出为 342126.8，而 double 的运算结果为 342126.7。 现实生活中，很多情况下一点误差是允许的，但对于 OJ 这类在线评测，要求结果和测试点的预期完全一样，因此在 OJ 提交时，我们一般都会使用更精确的 double 甚至 long double 类型进行运算，平时写代码的根据自己的需求（精确度、内存等）而定。 请提交成功的同学将自己的代码提交到 GitHub 仓库。 当然，如果你还不会使用 Git，你可以暂时不提交，之后我们会有关于 Git 的简单使用的教程博客（暂时还没更新）和手把手教学沙龙，这周因为时间不合适，都咕咕咕了。待博客和沙龙都更新完了，各位可以再参考博客或沙龙，提交自己的代码。 本周题单：分支结构这周的题单是分支结构，16 道题必做的只有 P5711 【深基3.例3】闰年判断 和 P5712 【深基3.例4】Apples，都是在实际开发中经常遇到的情况（手写日期判断等情况，使用单数还是复数）。题解和下周题目会在下周五晚八点前公布~ document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });]]></content>
      <categories>
        <category>C++</category>
        <category>MSC 每周两题</category>
      </categories>
      <tags>
        <tag>小灰晖</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[WSL(Ubuntu)、Git 配置及简单使用]]></title>
    <url>%2F2020%2F11%2F18%2F2020-introduction-to-wsl-ubuntu-and-git%2F</url>
    <content type="text"><![CDATA[https://blog.lyh543.cn/linux/introduction-to-wsl-ubuntu-and-git/ document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });]]></content>
      <categories>
        <category>Git</category>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>小灰晖</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MSC 每周两题：前言 & 顺序结构]]></title>
    <url>%2F2020%2F11%2F13%2F2020-programming-of-the-week-1-preface-and-sequential%2F</url>
    <content type="text"><![CDATA[系列目录 MSC 每周两题：前言 &amp; 顺序结构 MSC 每周两题：上周题解 &amp; 分支结构 MSC 每周两题：上周题解 &amp; 循环结构 MSC 每周两题：上周题解 &amp; 数组 MSC 每周两题：上周题解 &amp; 字符串 MSC 每周两题：去年题解 &amp; 函数和结构体 MSC 每周两题：上周题解 &amp; 后记 前言这里是成电微软学生俱乐部 2020 年度 C 语言学习 Guideline。虽然不少专业在大一上已经开设了 C 语言程序设计相关课程，但是仍有其他专业的同学没有学习 C 语言（比如计院 hhhh）。 本系列文章将用六个星期的时间讲述六个专题——————的题目。这些专题覆盖了编程入门（不仅是 C 语言）的最基本的要素，如果你已经精通了 C 语言（呃，是七天精通的那种精通），又正好在学习其他语言（如 Python、Java 亦或是 C# 等），你也可以参与其中，在学习的同时练习语法。 如果你还没有学习 C 语言，推荐翁恺 C 语言程序编程全系列，在 MOOC、bilibili 等视频网站上都能找到。（顺便安利翁恺老师的其他课程都很不错，老师很有人格魅力，声音还好听，女朋友就是看他的 Java 入门）。 不过，需要注意的是，每周一题专题并不是按照翁恺老师的 MOOC 的学习进度而设置的，而是使用了洛谷的程序设计入门题单。 洛谷是一个在线评测平台（Online Judge, OJ）。和平常的 做题-对答案 不同，在 OJ 中，你可以在线提交程序源代码（一般不限于 C 语言，根据系 OJ 支持情况而定），系统对源代码进行编译和执行，并通过预先设计的 测试数据（又称测试点）来检验程序源代码的正确性。OJ 常用于算法竞赛（如 OI、ACM 竞赛）中，也有面向求职者的 Leetcode，我们学校计算机学院的码图、软件学院的 OSTEC。 对于洛谷，在提交代码以后，如果测试点显示 AC(accepted)，表示你提交的代码在这个测试点的输入下的输出与答案相同。如果所有测试点均为 AC，则系统认为你提交的代码是正确的，你会在右边收获一个绿色的 Accepted，你的个人主页的“通过”数也会 +1。 顺便一提，当代码复杂起来，如果想要严格证明代码、或者说算法的正确性，这是相当困难的。因此 OJ 普遍采用的方法是，使用多组测试样例（在 ACM 竞赛中，甚至可能上百、上千）来尽可能找到你的代码的错误。如果没有找到你的代码的错误，就认为你的代码是正确的（实际上并不一定是正确的）。 本周题单：顺序结构回归正题，我们第一周的题单是顺序结构。题单中有 12 题，但你只需要完成 P5704 【深基2.例6】字母转换 和 P5708 【深基2.习2】三角形面积 即可。学有余力的同学可以选做题单中的剩下题目。六周以后，总共完成了 12 题及以上的 MSCer，将在年会获得精美小礼品一份~ 下周五晚八点前，我会提供这两道题目的 C 语言题解和简单讲解，同时放出下一周的题单。如果在完成过程中遇到了任何问题，也可以在 MSC 群里放出代码，大家一起讨论（推荐使用 https://paste.ubuntu.com/ 粘贴代码，而不是把代码发到 QQ 聊天框、截图甚至使用手机拍电脑）。 最后，如果对这个版块有好的建议或意见（如题解不够详细、需要线下讲座等），欢迎私聊小灰晖~ document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });]]></content>
      <categories>
        <category>C++</category>
        <category>MSC 每周两题</category>
      </categories>
      <tags>
        <tag>小灰晖</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Use Git to Collaborate]]></title>
    <url>%2F2020%2F10%2F07%2F2020-use-git-to-collaborate%2F</url>
    <content type="text"><![CDATA[学会使用 Git 和 Github 与他人合作参与项目 https://luosuu.github.io/post/use-git-to-collaborate/ document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });]]></content>
      <categories>
        <category>Git</category>
      </categories>
      <tags>
        <tag>Luosuu</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Microsoft Learn Python Path]]></title>
    <url>%2F2020%2F10%2F03%2F2020-microsoft-learn-python-path%2F</url>
    <content type="text"><![CDATA[使用 Microsoft Learn 入门编程并激发创意 https://luosuu.github.io/post/microsoft-learn-python-path/ document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });]]></content>
      <tags>
        <tag>Luosuu</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[电子科技大学常用网站]]></title>
    <url>%2F2020%2F09%2F04%2F2020-uestc-websites%2F</url>
    <content type="text"><![CDATA[本文更新于 2020.11.21，文中信息可能已失效。更多信息可见：https://blog.lyh543.cn/others/something-about-uestc/ 常用网址最常用的网站推荐直接记域名，直接敲域名比在官网反复跳转快多了。 教务系统：http://eams.uestc.edu.cn/eams 一卡通，可进行挂失：http://ecard.uestc.edu.cn 学生邮箱（注意事项）：http://mail.std.uestc.edu.cn 教务处：http://www.jwc.uestc.edu.cn 教务系统联系方式一览表：http://www.jwc.uestc.edu.cn/web/News!view.action?id=64 校历、全校课表、培养方案（电子版）、各类（查分、转专业）申请表、均可在教务处网站搜索到 清水河畔（校内论坛）：https://bbs.uestc.edu.cn/ 校车 396路 通勤车时刻表：https://bbs.uestc.edu.cn/forum.php?mod=viewthread&amp;tid=1430861 返校代理（注意事项）：https://vpn.uestc.edu.cn/ 图书馆预约研修室：http://reservelib.uestc.edu.cn/ 在线教材（官方只提供了少部分教材，且几乎没有课程提供 PDF）：http://zxkc.uestc.edu.cn/ 学校官网是 www.uestc.edu.cn，必须加 www！uestc.edu.cn 域名是没有 A 记录的。教务处网站也是如此。 学校地址中/英文官网拉到最下面即是。 中文 英文及邮编 清水河 成都市高新区（西区）西源大道2006号 No.2006, Xiyuan Ave, West Hi-Tech Zone, 611731 沙河 成都市建设北路二段四号 No.4, Section 2, North Jianshe Road, 610054 九里堤 成都市九里堤西路8号 610031 学生邮箱 学生邮箱无需“激活账号”，可直接登录，默认密码是身份证号倒数第七位至倒数第二位。 目前尚不清楚学生邮箱在大一进校以后多久可用，保守估计这个时间在一个月以内。 学生邮箱可用于申请： 一个包含 1T Onedrive 空间的账号 JetBrains 全家桶 由于泥电学生邮箱是外包的且没有购买 SSL 证书，在邮箱客户端使用 IMAP、POP3 等不能使用 SSL 证书进行验证。强制要求 SSL 的客户端（如 Outlook for Android）似乎无法登陆学生邮箱（可以使用 Gmail 代替）。 由上条原因，以及推送可能不及时等问题，建议仅将学校邮箱用于申请上述学生优惠，不要作为主力邮箱。 返校代理登录 https://vpn.uestc.edu.cn/ 后即可通过在浏览器中修改网址达到用学校 IP 访问任意网址的效果。 http://www-uestc-edu-cn-s.vpn.uestc.edu.cn:8118/ 将会代理到 https://www.uestc.edu.cn/可见，将原网址中的 . 改写为 - 即可成功代理。 以下为更多规则： 规则 例子 实际访问网站 原网址中的 . 需改写为 - 原网址中的 - 需改写为 -- 访问指定端口，需在后面加上 -&lt;端口号&gt;-p http://www-uestc-edu-cn-80-p.vpn.uestc.edu.cn:8118/ http://www.uestc.edu.cn:80/ 以 https 协议访问，需在最后加上 -s http://www-uestc-edu-cn-s.vpn.uestc.edu.cn:8118/ https://www.uestc.edu.cn/ 以 https 协议访问指定端口，使用 -&lt;端口号&gt;-p-s http://www-uestc-edu-cn-443-p-s.vpn.uestc.edu.cn:8118/ https://www.uestc.edu.cn:443/ eduroam 的账号密码 来源：https://info.uestc.edu.cn/info/1044/1631.htm eduroam 联盟用户连接 SSID：eduroam，802.1x 认证，为全球 eduroam 联盟成员提供上网服务，eduroam 联盟内全球漫游。 我校师生的用户名为：工资号或学号@uestc.edu.cn，如：工资号 123456 对应的账号为 123456@uestc.edu.cn，密码为统一身份认证密码。 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });]]></content>
      <tags>
        <tag>小灰晖</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[parcel速食指南]]></title>
    <url>%2F2020%2F02%2F12%2F2020-parcel%E9%80%9F%E9%A3%9F%E6%8C%87%E5%8D%97%2F</url>
    <content type="text"><![CDATA[✨ 前言web前端发展速度以迅猛著称。js在出生以来，一直在经历一次又一次的变化。自从服务器端js(nodejs)出现到现在，前端技术群阀割据。当前已经形成了以webpack为核心，babel，等技术独霸一方的局面。 无论是想用什么框架，似乎搭建环境成为了最大的难题。web前端工程师，不知什么时候成为了配置文件工程师。 本文将带领大家认识一个新兴的打包工具parcel，为前端0基础从同学打造一篇速食指南。 🍳 parcel简介parcel是一个零配置打包工具。 对前端不了解的小伙伴们可能不知道，前端开发目前已经发展到了相当复杂的地步。学会html，css，js只是开始。项目的源码结构一定要便于人理解，但是项目层级的递增，文件数量增加都会导致网页性能的下降。加上源代码中有大量的注释，空行等无效部分，web前端项目从编写完到优化需要经历多个工序。诸如：代码压缩，资源合并，目录结构扁平化等等。当然，这些工序都有成熟的工具和方法来进行，并不需要开发人员烦恼具体的处理方法。打包工具正式因此产生的。不夸张的说，js现在已经完全像一个编译语言一样了。项目的源代码，与编译后的结果完全是两个样子。 打包工具的配置一直是个难题。webpack的配置，会随着项目使用开发技术的增加而增加。webpack配置文件，可以说是对快速原型开发最大的阻碍。所以，当前热门的web前端框架。如vue,react,angular都有自己的脚手架来方便的快速产生一个demo项目。而随着使用技术的增加，web前端开发者需要主动编辑webpack配置文件。这个时候仅仅是噩梦的开始。随之而来的，babel配置，ts配置将把程序员拉向深渊。 零配置，顾名思义，不需要写配置文件。这正是parcel存在的理由和意义。简而言之，parcel最大的优点： 极速的原型开发(再也不需要管配置文件了) 降低前端入门难度 这些，也正是我带来这篇教程的理由。 📕 菜单接下来我们进行一些准备工作 安装最新版本的node和npm(服务端js的执行环境和包管理器) 没了(好吧就这样吧) nodejs首页链接，到这里下载一个nodejs。并且正确的配置环境变量等东西(我猜安装程序是自动配置的，毕竟python会，如果不是问问百度怎么装好这个东西) 🍽 开始parcel快速开始，到这里参考parcel的官方教程。不过这个官方教程和typescript的一样，开头不由分说的直接要你全局安装parcel。这样的瓜皮操作会让你的项目在别的地方跑不起来。建议按照我的来走(不过肯定有人爱走弯路)。 🍎 初始化项目新建一个空的文件夹，作为项目目录。进入其中，按住shift右键单击，选择在此处打开powershell窗口。这个选项不按住shift没有，是一个Windows的神奇操作。当然，非Windows用户，我就当你什么都懂了😁。 输入以下命令初始化项目1npm init -y 新建.gitignore文件，输入以下内容1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162.vscode.cachedist# Logslogs*.lognpm-debug.log*yarn-debug.log*yarn-error.log*# Runtime datapids*.pid*.seed*.pid.lock# Directory for instrumented libs generated by jscoverage/JSCoverlib-cov # Coverage directory used by tools like istanbulcoverage # nyc test coverage.nyc_output # Grunt intermediate storage (http://gruntjs.com/creating-plugins#storing-task-files).grunt # Bower dependency directory (https://bower.io/)bower_components # node-waf configuration.lock-wscript # Compiled binary addons (https://nodejs.org/api/addons.html)build/Release # Dependency directoriesnode_modules/jspm_packages/ # Typescript v1 declaration filestypings/ # Optional npm cache directory.npm # Optional eslint cache.eslintcache # Optional REPL history.node_repl_history # Output of 'npm pack'*.tgz # Yarn Integrity file.yarn-integrity # dotenv environment variables file.env gitignore是我从网上随便找的一份稍加修改的，你可以用的时候自己改，比如mac用户加上.DS_Store等 接下来初始化git仓库 123git initgit add .git commit -m"init" 你要是git都没有，或者不会用。emmm，我怎么 隐 隐 约 约 记得我这个文章就是发布在GitHub Pages上面的呢？ 接下来按照自己的情况，决定是否把仓库发布到诸如github，gitlab，gitee等地方备份或者分享。 🍎 安装依赖12npm install -D parcel-bundlernpm install normalize.css 分别安装了parcel打包工具(开发依赖)，和normalize.css(项目依赖)。这两者的区别在于parcel是用来打包的，我们项目的最终结果里面没有他(工具人)。normalize.css是屏蔽浏览器见差异的初始化样式。 🍎 代码编写创建index.html 和 main.js 创建index.html1234567891011&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt; &lt;head&gt; &lt;meta charset="utf-8"&gt; &lt;title&gt;养🐷计划&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;div id="app"&gt;&lt;/div&gt; &lt;script src="./src/main.js"&gt;&lt;/script&gt; &lt;/body&gt;&lt;/html&gt; 创建src文件夹，在其中创建main.js1234567import Vue from 'vue'import App from './App'new Vue({ el: '#app', render: h =&gt; h(App)}) 在src文件夹中，创建App.vue123456789101112131415161718192021222324252627282930313233343536373839404142434445&lt;template&gt; &lt;div class="app-root"&gt; &lt;div class="display"&gt;你的体重：{{weight}}Kg&lt;/div&gt; &lt;div class="eat" @click="eat"&gt;吃&lt;/div&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default { data() { return { weight: 55, } }, methods: { eat() { this.weight += 1 } },}&lt;/script&gt;&lt;style&gt;.app-root { display: flex; padding: 30px;}.display { font-size: 42px;}.eat { font-size: 36px; color: red; border: 5px solid red; height: 50px; width: 50px; border-radius: 50px; display: flex; align-items: center; justify-content: center; user-select: none; cursor: pointer; margin-left: 30px;}&lt;/style&gt; 🍎 构建脚本在package.json的scripts中添加两个字段，如果你的项目里面原来是这样123"scripts": { "test": "echo \"Error: no test specified\" &amp;&amp; exit 1"}, 添加完应该是这样12345"scripts": { "test": "echo \"Error: no test specified\" &amp;&amp; exit 1", "dev": "parcel index.html", "build": "parcel build index.html"}, 🍎 运行开发服务器1npm run dev 进去吃点东西 🍎 打包1npm run build 运行命令后产生dist文件夹，里面的内容是要发布到服务器的最终结果。如果你想试试但是没有服务器，可以自己弄个GitHub Pages。然后给自己的朋友玩一玩。 🍇 总结这篇文章带大家了解了以下parcel的基本使用方法。里面使用了vue框架，但是没有进行任何配置，拿来就用。同样，如果你喜欢，可以直接用react，pug，less，sass等技术。最夸张的，甚至可以直接在前端项目中写rust😲。这会自动被编译成wasm。 最后，文章写的仓促，欢迎大家提出意见和建议，指出错误。 当然，欢迎投喂。 作者QQ：pc or mobile document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });]]></content>
      <categories>
        <category>web前端</category>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>万事屋</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[计算机的数值表示和运算]]></title>
    <url>%2F2019%2F11%2F04%2F%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%9A%84%E6%95%B0%E5%80%BC%E8%A1%A8%E7%A4%BA%E5%92%8C%E8%BF%90%E7%AE%97%2F</url>
    <content type="text"><![CDATA[进制转换我们都知道计算机底层数值都是二进制的（由高低电平表示）。而我们生活中常用十进制，同时一些场合下也会用16进制。因此首先我们需要知道进制之间如何转换。 二进制转十六进制二进制数以小数点为界，整数部分从小数点从左到右数，每4位分为一组，不足四位的时候在左端补0；小数部分从小数点从右往左数，每四位为一组，不足四位则在右端补0。然后每组按照二进制数与十六进制数对应关系转换。因为2的四次方为16，所以十六进制的每单个数都可以用四位二进制数表示出来。 十六进制转二进制直接每位十六进制数都对应转换为四位二进制数即可。 二进制转十进制(101.01)_2=1*2^2+0*2^1+1*2^0+0*2^-1+1*2^-2十进制转二进制十进制整数十进制数不断除二，记录下每一次的余数，直到商为0。先得到的余数是二进制中的低位，后得到的是二进制整数中的高位。 十进制小数小数位不断乘二，记录下每一次结果的整数位（当然只有0或1），直到小数位为0。先得到的整数位是二进制中的高位，后得到的整数位是二进制中的低位。 0.3125*2=0.625 \\ 0.625*2=1.25\\ 0.25*2=0.5\\ 0.5*2=1因此记录下来的二进制数为0.0101。即 0.3125 = (0.0101)_2当然存在无法达到小数位为0的情况。视精度进行取舍，假如要求五位精度，求到第六位看第六位是0还是1，如果是0直接舍去，如果是1则在第五位进位。 补码制表示二进制数上面我们讨论的二进制数都是无符号数，也就是无法用来表示这个数的正负。容易得知无符号数的表示范围是 [0,2^n-1]我们思考一种简单的标志正负的方式，如果用n位来表示一个数，那么我们用最高位来标志这个数的正负，一般最高位为0代表正数，最高位为1代表负数。此时最高位我们称为符号位,剩余的n-1位称为数值位。带有符号的数我们称之为符号数。 考虑此时的n位二进制数的表示范围，以四位为例，对正数而言最大为0111，负数的表示范围为1111（-8）到1001（-1），此时0有1000和0000两种表示方法。也就是表示范围为 [-2^{n-1} , 2^{n-1}-1]但是这样做会增加运算逻辑的复杂程度，因为加法器要先检查操作，然后再检查二者的符号：符号相同则将二者数值位相加然后赋给结果相同的符号位；如果符号不同还需要比较二者数值部分的大小，用较大的减去较小的，然后赋给结果较大的操作数的符号。 因此我们引进补码制来表示符号数。实际中的计算机符号数都是用补码制表示的。所以以后符号数就等同于补码制二进制数。 补码运算我们先来了解一下补码：一个n位二进制数D的补码为 2^n-D_2求补码的运算我们称之为补码运算。 补码运算可以变形 2^n-D\\ =(2^n-1-D)+1而$2^n-1-D$实际就是n位全1二进制数减去D，相当于对D取反。也就是说求D的补码的过程实际可以变成求D的补码然后再加一。这个运算过程对计算机硬件来说比减法容易得多。 补码制表示规则和性质在补码制下同样用最高位表示符号，且0为正，1为负。 十进制数3的四位补码制二进制数同样为0011，而补码制下的负数为正数的补码。也就是-3表示为 1100_2+1=1101_2如果你对补码制下的负数再进行补码运算，会得到该数的相反数，也就是变回正数。 0010_2+1=0011_2这使得在补码制下正数与负数的相互转换非常方便，一对相反数互为对方的补码。 考虑n位补码制二进制数的表示范围，以4位为例： 正数最大为0111 负数可以从 1000（-8）～1111（-1）注意和非补码制的区别 0为0000，且0的补码仍为0000。 也就是 [-2^{n-1},2^{n-1}-1]补码制下的拓展对于无符号数，由于没有符号，从4位二进制数拓展到8位只需要在左端加四个0。称这种拓展方式位零拓展 对于符号数，我们需要考虑它的符号，拓展的规则是直接按照它的符号位进行拓展，也就是1101拓展到8位就表示为了11111101。 我们可以求一下拓展前后的补码验证一下，前者的补码为0011，也就是3，后者为00000011，也是3。 对符号数的位数拓展方式我们称为符号拓展 运算加减补码制的提出是为了简化运算。在补码制下运算不需要考虑符号位，符号位直接参与运算即可。并且如果操作为减法，那么就对后面的操作数求补码然后按加法运算即可。而且如果最高位产生了进位直接舍去最高位进位即可。 1110+1010=1000溢出运算正确的结果超出了给定的取值范围，就是溢出。这里给出的取值范围就是n位二进制补码表示的范围。 最高位进位和溢出没有直接关系，可以证明异号相加不会溢出，同号相加才有可能溢出。 如 0100+0110=1010正确结果10超出了四位符号数的表示范围。 判断溢出的方法很简单，如果两个相同符号的数相加，运算结果的符号位变化，那么就可以判断产生了溢出。 乘除略 逻辑运算移位总位数不变 左移:右端直接补0，1110左移两位—1000 逻辑右移：左端直接补0，1110逻辑右移两位—0011 算术右移：左端根据符号位补，1110算术右移—1111 左移和算术右移本质为乘2的n次方（不丢有效位1的情况下） 按位运算省 浮点数的表示和运算我们现在开始考虑如何来表示小数。 首先确定正负，我们还是取最高位为符号位，值用S表示。 先不考虑小数点在哪里，先将这个值用无符号数的方式表示出来，这个过程中我们需要确定我们要取多少位，也就是有效长度。 假设我们取a位有效长度，然后用a位的空间存储这个有效值A。 最后我们通过移位的方式来确定小数点在哪里，实现方法是在后面用n位的长度用补码的方式存一个阶数,小数点从有效值的最右端根据阶数的值E移位。 根据标准二进制浮点数运算标准IEEE-754，移位应该进行到有效值的最高位的后一位，也就是有效值那里的实际值永远是1.x，也就是在该规则方式下，我们用 (-1)^S*1.x*2^E来表示带有小数部分的数。x我们称为尾数部分。 在实际的存储中，如果尾数部分长度为m，那么a=m+1，因为1是公有的所以不需要特别去表示它，直接表示x的部分就行了，也因此存在一个隐藏位1。 实际中我们需要经常比较阶数部分，为了方便比较，阶数部分实际存储的值都是阶数E+2^(n-1)-1,阶数部分存储的值我们称为阶码，其范围就变成了[000···000, 111···111]，实际表示的范围[-2^(n-1)+1,2^(n-1)]，这样比较两个浮点数的阶数就很方便了，直接比较的是阶码也就是无符号二进制数。 根据浮点数标准IEEE-754，有两种浮点数，即单精度浮点数和双精度浮点数。 二者的符号位都是1位。单精度的阶码位数有8位，尾数有23位；双精度阶码有11位，尾数有52位。 几个特殊值浮点数0:尾数全为0，阶码全为0 无穷：尾数全为0，阶码全为1 无效操作数：尾数不全为0，但阶码全为1 因此实际储存中为了正常表示非0浮点数，阶码不能全为1或者0。 浮点数运算 移位使得两个数的阶码相等，小阶去对等大阶，不要忘记了隐藏位1。 尾数作运算，为了对应可能产生的进位，需要把隐藏位拓展为两位01。 将隐藏位恢复为1，化为标准的浮点数 如果阶码减小到全为0，说明结果的指数太小，出现下溢；如果运算后阶码全变成1，说明结果的指数太大出现上溢。 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });]]></content>
      <categories>
        <category>科普</category>
      </categories>
      <tags>
        <tag>Luosuu</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python基础杂烩]]></title>
    <url>%2F2019%2F10%2F15%2FPython%E5%9F%BA%E7%A1%80%E6%9D%82%E7%83%A9%2F</url>
    <content type="text"><![CDATA[2019Python学习小组持续更新博客二, 这篇文章列出了一些我认为Python学习者应当知道的一些基础内容 Python解释器实现 版本 实现方式 特点 CPython C语言写的Python 速度快 JPython 由Java编写的Python 可以直接调用Java的各种函数库 PyPy 由rPython编写的Python 更灵活, 易于使用和试验 IronPython 以. NET和Mono实现的Python 面向NET和ECMA CLI的Python实现 ZhPy 只是把Python翻译了一遍而已 又称中蟒, 可以完全用中文编程. 但中蟒目前已经停止更新了. 我们通常所说的Python是CPython, 👇Python官方页面提供的是CPython 版本Python这种语言有Python2和Python3两个版本, 两者语法有少许不同, 比如Python2和Python3中print()的使用有区别, Python2和Python3中input()接受的数据类型有区别等. 最新的Python2对大部分Python2, 3不同的语法做了兼容, 而在Python3对Python2的语法兼容性很差, 但是提供了一个叫2to3的脚本帮助我们将Python2的程序转换为Python3的程序. 哲学万物皆对象 python在设计初始是一种面向对象语言. 💡 面向对象是一种编程范式 数据类型Python是一门动态类型语言 类型注解在Python3中有了一个新特性: 类型注解 12def add(x:int, y:int) -&gt; int: return x + y 12def add(x, y): return x + y 正如其名, 注解只是标注一下, 有了类型注解的程序和没有类型注解的程序运行起来没有区别, 但它能帮助程序员更好的发现问题, 也能让IDE提供更准确的代码补全和语法检查. 类型检查有时候为了保证程序的严谨性我们会检查一下变量是不是我们设想它应该是的类型, 这个时候我们用 isinstance() 之所以不使用 type() 是因为 type() 不会认为子类是一种父类类型, 不考虑继承关系. 举例说明: 不可变对象❗️ 我们可以给不可变对象重新赋值, 但其内存地址会改变. 以下是体现给可变对象/不可变对象重新赋值时它们的内存地址变化的例子. 💡 id()能获取一个变量的内存地址 Number (数字) int (整数) long (长整数) float (浮点数, 即小数) bool (布尔值, 即 True 和 False ) Python中的Number我认为是比较特殊的, 因为它在内存中占用的空间大小是变动的.(在CPython中是如此, 但不知道为什么在IronPython下不是) 💡 用sys.getsizeof()可以知道一个变量的占用的内存大小 String (字符串)Tuple (元组)可变对象可变对象可能带来的危险举例: 12345678def myfunc(l = []): l.append('add') print(l)myfunc([1, 2, 3])myfunc([1, 2, 3])myfunc() List (列表)💡 string和tuple都是特殊的list Set (集合)Dictionary (字典)👇 在网上偷的string, tuple, list, dictionary的突出区别比较. 名字 是否可变 是否可迭代 是否可切片 访问方式 写法举例 string no yes yes 下标索引 “abcd” tuple no yes yes 下标索引 (‘a’,‘b’,‘c’,‘d’,‘abcd’) list yes yes yes 下标索引 [‘a’,‘b’,‘c’,‘d’,‘abcd’] dictionary yes yes no 关键字索引 {‘1’:‘a’,‘2’:‘b’} Python中有关对象需要注意的问题python中向函数传递参数只是引用传递: 如果参数为可变对象, 在函数中变化会影响引用的这个变量, 而不可变对象不会. 在向类传递参数时也是如此. 基础语法Python内置帮助文档1help() 调用help()后就会进入Python内置帮助文档, 然后输入想查的类名/函数名/属性名就可以看到对应的帮助文档. :bulb: 要注意输入的只有名字, 不带括号什么的, 以及要看一个包里的函数文档时需要先引用该包. 比如如果想查看time.time()的帮助文档, 首先import time, 然后输入help()进入帮助文档, 然后输入time.time, 就会看到time.time()函数的帮助文档. 按一次q退出time.time()的文档, 再按一次q退出帮助文档返回交互式Python界面. 注释在Python中 # 开头的为注释 特殊注释shebangshenbang (hashbang) 指的是以 #! 开头的语句. Linux操作系统的程序加载器会分析 Shebang 后的内容，将这些内容作为解释器指令，并调用该指令，并将载有 Shebang 的文件路径作为该解释器的参数. 因为在很多语言中以 # 开头的是注释, 所以不会影响程序. 编码格式有的python文件是这么开头的: 12#! /usr/bin/python# -*- coding:utf-8 -*- 第一行是给Linux系统的程序加载器看的, 因此在Windows下不需要这句, 第二句是指定文件的编码格式为UTF-8, 避免文件中的非ASCII字符被识别为乱码. docstring123456def func(int x, int y): """ 这里是docstring, 是特殊的注释, 能让IDE, 编辑器在鼠标移动到有docstring的函数, 类上时显示这段docstring """ passa = func(i) 条件语句及循环if, elif, else下面是按a &lt; 10, 10 &lt; a &lt; 20, 20 &lt; a &lt; 30, a &gt; 30分类的举例. 12345678if a &lt; 10: passelif a &lt; 20: passelif a &lt; 30: passelse: pass 另外有一种one liner会很喜欢的用法: 1a = 2 if 2 &gt; 3 else 4 上面这句与下面这句等效. 1234if 2 &gt; 3: a = 2else: a = 4 生成器 ·迭代器·range语法类似于切片 推导式推导式comprehensions（又称解析式）, 是Python的一种独有特性.推导式是可以从一个数据序列构建另一个新的数据序列的结构体. 换句话说能从一组数据中求出满足条件的新数据, 比如a, b两个等长列表中都为偶数的项的乘积. 共有三种推导式, 在Python2和3 中都有支持: 列表推导式 字典推导式 集合推导式 列表推导式的语法: 1l = [output_expression for out_exp in input_list if expression] 使用举例: 1234567# 1a = [i for i in range(30) if i % 3 is 0]# 2names = ['Bob','Tom','alice','Jerry','Wendy','Smith']LONG_NAMES = [name.upper() for name in names if len(name)&gt;3]# 3a = [x*y for x in range(1,5) if x &gt; 2 for y in range(1,4) if y &lt; 3] 切片因为tuple, string其实都是特殊的列表, 所以列表, 字符串, 元组都可以进行切片. 语法: l_sliced = a[begin : end : step] 12l = [1, 2, 3, 4, 5, 6, 7]l_sliced = l[1:5:2] 在没有numpy库的情况下多维切片是通过推导式实现的: 12a = [[1, 2, 3], [4, 5, 6], [7, 8, 9]]b = [a[i][:-1] for i in range(1, 3)] 函数💡 要注意函数名后的 () 也是一种运算符, 称为函数调用运算符. 如果调用函数的时候不加()只会创建一个该函数的对象而不会调用它. 定义函数python中以 def 关键字定义函数, 结构如下: 12def 函数名(参数列表): 函数主体 python中的函数可以有返回值也可以没有返回值 123456def func1(): passdef func2(l): l.appeend('add')def func3(x, y): return x + y 用字典来实现case示例: 1234567891011121314151617181920def print1(): print('111')def print2(): print('222')def printdefault(): print('default')dic = { 'a': print1, 'b': print2, 'default': printdefault}i = input('input: ')main = dic[i if (i != 'a' or i != 'b') else 'default']main() 编码格式字符串经过编码（encode） 就成为了一堆数据, 反过来, 数据经过解码（decode） 就变回我们认识的字符串. 指定文件编码格式为 utf-8 1# -*- coding:utf-8 -*- 💡 如果不指定文件编码格式在有的Python2版本中无法识别中文, 即便是中文注释也会报错. Linux系统默认编码格式是UTF-8, 系统语言是简体中文时Windows10的编码格式是GB2312 (也称GBK, 国标扩展, cp936) 在python中 str 类型数据都以Unicode码点格式储存, 因此直接打印字符串会看到字符为’\u’开头 基本读写1234f = open("test.txt", "r+")f.read()f.write("text")f.close() 或者 123with open("test.txt", "r+") as f: f.read() f.write("test") 💡 使用with语句打开文件是最推荐的方式, 原因见这里 下表是open时要指定的读写模式的比较. 读写模式 是否可读 是否可写 文件指针位置 作用 r 是 否 文件开头 读取文件, 如果文件不存在则报错 r+ 是 是 文件开头 读取并写入文件, 如果文件不存在则报错 w 否 是 文件开头 覆写原文件, 如果文件不存在则创建 w+ 是 是 文件开头 读取并覆盖写原内容, 如果文件不存在则创建 a 否 是 文件末尾 追加文件内容, 如果文件不存在则报错 a+ 是 是 文件末尾 追加文件内容并且可读, 如果文件不存在则报错 另外还有b模式, 以二进制打开, 允许我们对二进制文件进行编辑, b可以与其他模式组合使用, 比如rb 🔗 python基础-文件读写’r’ 和 ‘rb’区别 脚本和普通程序的区别脚本这个词来源于戏剧, 能用于舞台演出的戏剧文本就称为脚本. 在编程中的脚本是解释执行的程序, 通常只用来做简单的处理, 做自动化处理 解释器的使用技巧在解释器中交互式编程时要注意缩进不要错 清屏python解释器本身没有清屏命令, 只能通过调用命令行的清屏命令来达到效果 12345import os# Windows下os.system('cls')# Linux下os.system('clear') 代码风格我推荐遵从PEP8. 当然一行一行看完这个规范不是一件令人愉快的事, 最简单的时刻遵守PEP8的方式是在代码工具里安一个代码风格检查器 (linter).检查你的代码是否符合PEP8的linter是pycodestyle 💡 在VSC中可以在设置中搜索python.linting.pycodestyle, 勾选Pycodestyle Enabled, 这样在VSC中编写Python代码时使用的linter就是pycodestyle啦 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });]]></content>
      <categories>
        <category>Python</category>
        <category>Python基础</category>
      </categories>
      <tags>
        <tag>LeoJhonSong</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【学术沙龙预告】Python入门]]></title>
    <url>%2F2019%2F10%2F12%2F%E5%AD%A6%E6%9C%AF%E6%B2%99%E9%BE%99%E9%A2%84%E5%91%8APython%E5%85%A5%E9%97%A8%2F</url>
    <content type="text"><![CDATA[活动预告 你 想不想开发自己的网站？ 想不想做出众多新奇有趣的小玩意？ 想不想写出属于自己的人工智能？ 来吧 开启新世界的大门 内容预告 本次沙龙活动会由宋铸恒学长为我们带来Python的入门，相信这次一定会给我们带来满满的收获。另：本次活动会简单介绍宣传一下MSP 时间地点 时间：周日下午3:30 地点：品学楼C231 主讲人 &nbsp; &nbsp; 宋铸恒，电子科技大学2017级格院学生。大一加入了程洪教授的实验室，在大二暑假进入文力教授的实验室，有着三年的项目经验，是一位对于Python非常精通的学长。曾经获得芯空杯四轴单片机大赛二等奖，大学生电动方程式大赛优秀奖。 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });]]></content>
      <categories>
        <category>活动</category>
        <category>沙龙</category>
      </categories>
      <tags>
        <tag>辉尘T</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Ubuntu虚拟机中Python环境配置]]></title>
    <url>%2F2019%2F10%2F09%2FUbuntu%E8%99%9A%E6%8B%9F%E6%9C%BA%E4%B8%ADPython%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE%2F</url>
    <content type="text"><![CDATA[我们这个在Windows的Ubuntu虚拟机里的Python环境配置分四步: 安装Vmware Workstation Pro 15 创建Ubuntu18.04虚拟机 安装Ubuntu系统 在虚拟机安装Anaconda3 安装VMware Workstation 15 Pro我们通常说的安装Vmware说的是VMware Workstation Pro, 是付费的 (可以在网上找激活码来激活), 其实另外有Vmware Workstaion Player, 个人使用的话是免费的,安装包也比Pro小不少 (Pro大约550M, Player大约140M), 它们的区别仅在于Pro版多了共享剪贴板, 快照, ssh连接Linux虚拟机, 同时运行多个虚拟机, 运行加密虚拟机等一些功能, 体验更好, 因此推荐安装Vmware Workstaion Pro. 🔗 最新版VMware Workstation Pro下载链接 🔗 最新版Vmware Workstation Player下载链接 本教程中安装的是Vmware Workstaion Pro 安装过程只有👇 这一个界面是需要操作的, 勾选增强型驱动程序, 选一下安装位置, 其他界面就按下一步之类的. 安装好后会提示重启一下,不过不重启也能继续下面的步骤. 第一次打开Vm会要求输入激活码, 这时输入我从网上随便搜的👇 这个就能激活了 ZC10K-8EF57-084QZ-VXYXE-ZF2XF Vmware安装完成🎉 创建Ubuntu18.04虚拟机首先我们需要下一个Ubuntu Desktop安装镜像. 🔗 Ubuntu下载链接 虽然目前已经有了19.04版的Ubuntu, 但并不建议新手尝试, 这些刚出的版本通常包含很多仍在修复的错误, 并不适合新手学习Linux. 实际上大多数不是软件开发者的Ubuntu使用者不会可以追求新版本的Ubuntu, 现在仍有很多人用的是1604. 💡 LTS是Long Term support, 意味者长期支持, 这些版本会更稳定些. 非Ubuntu开发者通常选择这些版本的Ubuntu. 打开Vmware, 点击创建新虚拟机, 然后选择稍后安装操作系统 然后👇 然后设置一下这个虚拟机在Vmware中的名称 然后是设置虚拟机的硬盘大小, 就用它的建议值就可以. 如果日后空间真的不够了, 还可以扩容, 或者可以考虑上实体Linux了. 下面这个选将虚拟磁盘储存为单个文件就好. 然后点自定义硬件, 将ISO镜像选为下好的Ubuntu镜像. 另外如果你想多分点内存给虚拟机, 可以把内存一项改大一些 (其实这些东西在虚拟机建好后仍能更改). 满意了就可以开始创建了. 安装Ubuntu系统开机后, 系统语言选择英文 (即便选中文也没几句中文, 没意义) 💡 目前Ubuntu画面只占了一部分屏幕, 一会安了Vmware增强工具就能全屏了. 接下来设置键盘布局, 除非是跟普通键盘不一样的键盘, 都是默认的这个English (US)不用改 👇 这里为了节省时间选最小安装,刚试过普通安装需要约40min, 最小安装十多分钟. 当然最小安装只有很少的软件, 如果你有时间也可以选普通安装 点击Install Now后会提示选择时区. 在地图上的在中国上点一下就能把Shanghai填充上去 安装前的最后设置! name是你的昵称, 可以和用户名不同. computer’s name是主机名, 稍后我们会看到主机名和用户名会用在什么地方. 💡 用户名的格式较为严格, 只能用小写字母 💡 可以选说Log in automatically, 开机进入桌面不需要输入密码 等一会就安装好了! 按Ctrl Alt T打开终端, 可以看到提示符中@前的便是username, @后的便是hostname 最后安装一下Vmware增强工具, 能更好适配. 在刚打开这个终端输入下面命令 (因为这个增强工具还没装上, 暂时无法共享Windows和Ubuntu剪贴板 12sudo apt updatesudo apt install open-vm-tools-desktop -y :bulb: sudo命令会要求你输入密码 然后在终端输入reboot重启一下, 就能在Windows和Ubuntu间共享剪贴板啦🎉 ❗ 有一点比较坑, Vmware不支持笔记本电脑自带触摸板的滚动! 最好的解决方法是用鼠标. 安装Anaconda首先需要下一个anaconda安装包. 从anaconda官网下太慢了, 可以从清华anaconda镜像源下载. 拉到最底下是最新版本. anaconda清华源曾经关闭过一段时间, 最近才恢复, 可能是因为还在更新所以清华源上最新版本还是一年以前的. 不过问题不大, 安好了再更新也是一样的. 📑 Anaconda安装文档 安装过程参考👆 官方教程就好, 挺清晰的. 安装好后关闭运行anaconda安装脚本的那个终端, 再打开一个新的终端, 输入anaconda-navigator 在这里有anaconda配套的应用, 点击安装VS Code. 这样安装的好处是开箱即用: 打开VSC以后就能进行Python开发, anaconda已经将需要的插件, 需要的配置弄好了👍 完成! 这样我们就完成了基础版Ubuntu虚拟机中Python开发环境的搭建! 更多操作我们以后再做. document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });]]></content>
      <categories>
        <category>Python</category>
        <category>配置</category>
      </categories>
      <tags>
        <tag>LeoJhonSong</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2019MSC新生见面会 | 我们的故事从此开始～]]></title>
    <url>%2F2019%2F10%2F08%2F2019MSC%E6%96%B0%E7%94%9F%E8%A7%81%E9%9D%A2%E4%BC%9A-%E6%88%91%E4%BB%AC%E7%9A%84%E6%95%85%E4%BA%8B%E4%BB%8E%E6%AD%A4%E5%BC%80%E5%A7%8B%2F</url>
    <content type="text"><![CDATA[&nbsp; 与君初相识&nbsp; 犹如故人归&nbsp;&nbsp; 2019年9月28日，2019年的俱乐部新人在品学楼C231进行了一场欢(shi)脱(fen)有(hun)趣(luan)的面基大会，现场氛围十分火热，甚至不少同学当场留下了惩罚游戏的黑历史照片，相信这场见面会一定会成为萌新们大学生活的闪光回忆呢！(手动狗头） △勤劳的老咸鱼用零食饮料装点的现场 预热环节：辨认老咸鱼，由于萌新们辨认准确率令人震惊，这个环节很快就结束了...... △武汉大学的MSCer们 简单的预热环节之后就是短片放送~坚果叔叔张逸霄和纸盒叔叔王子和以及四川大学、武汉大学和上海交大的MSCer们都录制短片传达对萌新的寄语哦！主持人高天一用简单形象的统计图介绍了本次招新情况，不得不说我们MSC的男女比很震撼呢！（再次狗头） △物理学院的“半壁江山” △南上加南 破冰第一步当然是自我介绍！我们拒绝刻板的流程，采用了抽签决定发言时长的方式，有几个抽到3分钟的幸运鹅没有完成介绍任务，当场表演壁咚和《青藏高原》，气氛很快燃起来了，录像的吃瓜群众简直不要太开心~ 随后的签名活动更是将气氛推向更高点，立刻打破了羞涩腼腆的冰层，大家窜来窜去焦急寻找符合特征的那个人，争分夺秒收集签名，最后有五个小伙伴获得了奖品——定制U盘！ &nbsp; △我来康康是谁在划水 接下来的猜暗语游戏简直超出了见面会筹备组的想象，萌新过于机智以至于暗语题目根本不够用，无奈只好现场赶制纸条，甚是卑微啊！ 中场休息时，甜乐为大家简要介绍了微软学生俱乐部的现状，然后就是喜闻乐见的叠报纸！！！ △严肃点 这次主席团为叠报纸活动出的题目非常欢乐，内容扎实，覆盖面广，快速抢答的孩子们都快哭了。幸好活动之间有抽奖环节安慰受伤的心灵~ △非常欢乐的叠报纸 最后剩下一些题目用作个人抢答，回答错误的小萌新为大家带来了欢乐的演唱表演《我要O泡》，现场掌声雷鸣~每个活动的获胜组成员都获得了定制钥匙扣呢！ △只要你觉得严叔叔最棒，我们就是兄弟.jpg 最后大台阶合影，见面会在欢脱温馨的氛围中伴随着主席总结完结撒花~ △欢迎来到成电MSC的大家庭！ 文案：林柏澜 编辑：网友周某 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });]]></content>
      <categories>
        <category>活动</category>
        <category>见面会</category>
      </categories>
      <tags>
        <tag>林柏澜</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[软件自由日活动]]></title>
    <url>%2F2019%2F09%2F28%2F%E8%BD%AF%E4%BB%B6%E8%87%AA%E7%94%B1%E6%97%A5%E6%B4%BB%E5%8A%A8%2F</url>
    <content type="text"><![CDATA[Software Freedom Day 9月21 日是2019年的Software Freedom Day，电子科大Linux用户组和成都freeCodeCamp社区以及电子科技大学微软学生俱乐部一起举行了SFD活动。活动开展于电子科技大学沙河校区二教104。校内外爱好者积极参与了本次活动。 王康担任本次活动的主持人 钟天乐介绍微软与开源 还有一位来自成都freeCodeCamp社区的朋友谈到了编程入门门槛低、鼓励女性编程及重视编程者平等的观点并介绍了freeCodeCamp社区。 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });]]></content>
      <categories>
        <category>活动</category>
      </categories>
      <tags>
        <tag>林柏澜</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Markdown安利&Typora简要使用教程]]></title>
    <url>%2F2019%2F09%2F23%2FMarkdown%E5%AE%89%E5%88%A9-Typora%E7%AE%80%E8%A6%81%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[在此我来安利一下Markdown和Typora. Markdown安利什么是MarkdownMarkdown是一门语言, 一门我正用来写这篇博客所用的语言, 一门轻量级的标记语言 (Markup Language). 有没有觉得这个词很眼熟? 是的, HTML全称HyperText Markup Language. Markdown和HTML同属于MarkupLanguage(Markdown是一门Markup Language是Markdown作者的恶趣味), 它们与C, Python等编程语言并不是一类东西. Markup这个词源自印刷业, 指的是在电子排版技术出现之前人们对印刷物内容的排版进行标记的方式. 比如一段文字应当是粗体, 斜体,有下划线还是有删除线, 使用什么字体, 字体大小, 左页边距应当是多少, 一张图片该放在哪里, 多大等等… 💡 也就是说以前的人们在将原稿最终印刷出来前想知道会印成什么样基本靠脑补, 而现在我们称这个由标记语言文件得到最终效果的过程为渲染 (render). 而之所以我们说Markdown是一门轻量级的标记语言是因为在Markdown的语法比HTML等标记语言要简洁太多😆 一 二 比如👆 上面这个列表的Markdown实现代码为 12- 一- 二 而HTML实现代码为 1234&lt;ul&gt; &lt;li&gt;一&lt;/li&gt; &lt;li&gt;二&lt;/li&gt;&lt;/ul&gt; 但Markdown有时候也会让人觉得太过轻量级以至于缺少一些语法, 比如这个下划线其实是用HTML标签实现的. 好在你也可以在Markdown文件中写HTML, 如今的Markdown渲染工具基本都支持这个功能. 也是由于上面这个原因, 在Markdown作者们推出的CommonMark的基础上有了添加了更多语法的各种Markdown超集, 比如GitHub发布的GitHub FlavoredMarkdown. Markdown应用广泛吗实际上如今Markdown的使用相当广泛, 只要是支持所谓富文本的社区/论坛等, 比如说GitHub, 知乎, Stack OverFlow, CSDN博客, Wikipedia都是使用的Markdown. 另外因为Markdown和HTML的转换十分容易, 目前大多个人博客都是编辑Markdown格式的文章再生成HTML页面, 比如我正在码的也是Markdown文件. 再有就是目前大多数项目根目录的README文档都是Markdown格式, 而在线查看项目代码时GitHub等代码托管网站都会自动将项目中所有Markdown文件渲染出来. 为什么我们使用Markdown以下是网上的一些总结和我个人的体会. Markdown的设计理念是易读易写, 因此即便不渲染Markdown文件的可读性也很高,这让没有Markdown渲染工具的人也能很好地阅读, 而如果要脑力渲染HTML, 一会就眼晕了. 这种格式能让文档很方便的排列为很简洁好看的排版, 能让人专注于书写内容, 不必费神排版 支持代码按语言的语法高亮 能很方便的进行版本管理. 在要进行版本管理的项目中的Word文件简直是毒瘤, 不操作一番的话版本管理工具比如git并不能识别word文件具体变化, 而使用纯文本的Markdown能让每次的更改被体现出来! 占用空间小 (可以想一想一个word文档的大小) 能很容易地转为多种格式. Markdown和HTML是兄弟关系,因此Markdown文件能轻松转换成HTML文件格式以及HTML文件能轻易转换为的格式(PDF, jpg, Epub等)是显而易见的. 通过一些额外工具(比如Pandoc)的帮助,Markdown文件还能一键转化为更多文件格式,比如LaTeX, Word,OpenOffice, Media Wiki等. 能方便的插入图片, 表格, 超链接等 兼容HTML语法, 因此我们想让页面显示成什么样就可以显示成什么样 可以兼容LaTeX语法, 可以很方便的显示复杂公式 还可以兼容Graphviz, Mermaid等流程图工具等等… Markdown简明语法 一个标题以几个#开头, 空格后是文字. 以#的个数来表示第几级标题 以 - 开头接一个空格开始一个子弹列表, 以 1. 接空格开始一个有序列表 在要加粗的词两侧加 ** 来加粗. 如果要打出 ** 等特殊字符要在星号前加 \ 来转义 在行内代码两侧加 ` . 注意这不是单引号, 在我键盘上在Esc 键下面. 当然这个不只是用来放行内代码的, 也可以放别的. 在代码块上下行加 ``` , 第一个```后写代码的语言. 在Typora这个软件里插入图片很容易, 直接Ctrl V粘贴就好了, 或者右键, 里面有插入图片的按键. 插入图片的markdown语法是 1![当图片失效时此处显示的文字](图片地址) 插入超链接的语法和插入图片的语法很像, 此处举例说明. 这是点击进入百度的链接👉 百度 1[百度](https://www.baidu.com) 表格用|分隔每个元素, 第一行是各列的名字, 第二行的 |间是-, 分隔列名和值. 以下是一个例子 第一列 第二列 第三列 a b c 123| 第一列 | 第二列 | 第三列 ||-|-|-|| a | b | c | 💡 更详细的语法说明在Typora内可以查看Typora自带的Markdown语法参考手册 Typora安利那么用什么软件来写Markdown呢? 认准Typora! Typora的优点多到我不想写 (不其实是单纯不想写了), 最突出的优点我觉得是它的颜值,以及能直接将图片粘贴到文件中. Typora快速入门主题在Themes一栏可以切换软件的主题 大纲视图可以按这个OutLine或者按左下角的小圆圈触发大纲视图, 点击大纲视图里的标题可以快速跳转. 源代码视图按左下角这个\&lt;\/&gt;可以切换到源代码视图 拼写检查右下角这里可以选择进行拼写检查的语言或者关闭这个功能. 更多设置按这个Preference可以进行更多偏好设置. 以下是我的推荐设置 勾选对网路图片应用上述规则那直接粘贴从浏览器复制的图片时Typora会自动将该图片下载到这个指定文件夹. 建议开启插入时自动转义, 虽然这样会让中文 文件夹名变为乱码, 但这样无论文件夹名/文件名有多骚都不会出问题. 忽略单个换行让Typora遵循GFM: 单个换行不渲染为换行, 两个换行才渲染为换行 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });]]></content>
      <categories>
        <category>科普</category>
      </categories>
      <tags>
        <tag>LeoJhonSong</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[给电子科大新生们的软件推荐列表]]></title>
    <url>%2F2019%2F09%2F03%2F%E7%BB%99%E7%94%B5%E5%AD%90%E7%A7%91%E5%A4%A7%E6%96%B0%E7%94%9F%E4%BB%AC%E7%9A%84%E8%BD%AF%E4%BB%B6%E6%8E%A8%E8%8D%90%E5%88%97%E8%A1%A8%2F</url>
    <content type="text"><![CDATA[也许很多同学经常苦恼于找不到免费, 好用, 美观, 干净的软件. 这里为大家推荐一些十分好用的Windows平台电脑软件及部分安装教程链接. (破解软件的也帮你们找好了哦) 🌟🌟🌟 这里, 这里和这里有学校给大家提供的福利的说明 😏 必备 全局文件搜索工具 电脑管家 截图/贴图工具 压缩/解压缩工具 百度网盘破解版 视频播放器 音乐播放器 Chrome插件 必备 查词工具 网页截长图工具 稍后阅读 GitHub 下载仓库指定文件/文件夹 侧边栏显示仓库文件树 3D GitHub提交热力图 学术 谷歌学术搜索 一键跳转Sci-Hub 办公 Office全家桶 PDF阅读器 写作 文本编辑器 Markdown PDF Adobe全家桶 CAD MATLAB 系统安装/维修工具 系统启动盘烧录工具 PE盘 数据恢复 必备全局文件搜索工具只要你曾试过在Windows资源管理器中搜索文件你就会知道只要搜索范围稍微大一些这个搜索过程是多么长… 🔗 Everything 这款搜索工具让搜索变得十分迅速! 它甚至支持正则搜索等更高级的功能. 💡 Everything安装起来也很容易, 下载上面链接中的安装版64位, 安装引导中除了安装位置都维持默认选项即可. 电脑管家国内一提电脑管家那就是360, 鲁大师等一众流氓软件, 事实上他们给我们带来的困扰比便利更多, 不仅弹出各种迷之弹窗, 大多数还会捆绑下载一大堆奇奇怪怪的软件… 但清理垃圾, 管理开机启动程序等功能确实是需要的. 我推荐🔗 CCleaner 页面往下拉, 点击绿色的Download按钮即可下载免费版. 💡 安装后可以在设置中将语言调为中文. 另外默认情况下CCleaner总是会弹出提示可以更新的弹窗, 但这个检查更新的功能可以像这样关闭 截图/贴图工具我们都知道Windows自带的截图工具是很不好用的, 只能进行最简单的截图. 这里推荐🔗snipaste.snipaste不仅能截图, 还能简单的P一下截下来的图: 画线, 画框, 画箭头, 打码, 查看像素点颜色值… 而我觉得snipaste最惊艳的功能是他还能贴图, 也就是能把刚截的图直接显示出来, 可以挪动, 调整大小, 调整透明度. 比如当我们想对照着看课文里两个相隔很多页的段落时, 我们可以把其中一段截图并贴出来. 压缩/解压缩工具而压缩/解压缩工具最棒的无疑是🔗 Bandizip Bandizip支持的格式很多, 不必担心遇到无法解压的格式. 另外它的界面也很漂亮😄 百度网盘破解版国内分享大文件通常使用百度网盘, 但这东西如果不充超级会员会极大的限制下载速度 (不过在校园有些地方能达到2, 3Mb/s), 下载文件数量也有限制. 网上有好几个破解版百度网盘, 也有脚本能突破百度网盘下载速度限制, 但用来用去我还是觉得🔗 PanDownload 体验最佳. 💡 PanDownload不需要安装, 点击本地下载后将压缩包解压就可以点击其中的exe文件使用了. 另外PanDownload也有在线版 视频播放器虽然爱奇艺, 迅雷影音, 优酷等软件也能看外部导入的视频, 但如果我们想要一款单纯没有繁杂的视频推荐, 广告, 但又功能强大的视频播放器,PotPlayer当属最值得推荐的播放器. 💡 PotPlayer的官网被墙了, 无法翻墙的同学们可以从这里下载 音乐播放器和视频播放器的情况相同, 我们同样需要一个干净, 功能强大的无损音乐播放器, 那就是🔗foobar2000 foobar支持的音频格式众多, 解析度较好. 如果你觉得foobar界面有点简朴, 还可以更换皮肤 💡 foobar不默认支持的ape格式可以通过安装插件来支持. Chrome插件必备查词工具 🔗 沙拉查词是一款查词十分迅速便利, 弹出界面十分养眼, 可选功能很多的查词工具, 是chrome查词插件中毫无疑问最好的! 网页截长图工具 如果只是为了截普通的图有了snipaste的我们没必要再给浏览器单独装一个插件, 但🔗FireShot的惊艳之处在于它可以截长图. FireShot能将整个网页转为图片,, 也能截指定区域的长图. 稍后阅读 虽然我现在用的是chrome, 但我很喜欢edge的稍后阅读功能, 能把当前所有网页都关闭并放到稍后阅读的列表里. 一方面如果网页开多了浏览器十分吃内存, 一方面能将一部分目前暂时不看但还有用的网页收纳起来, 让网页变少一些, 心情也会好不少😆 可惜的是chrome并没有内置这个功能. 不过通过🔗OneTab这个插件倒是实现了稍后阅读的功能👍 GitHub下载仓库指定文件/文件夹 很多时候我们只想下载一个仓库中一部分文件而不是整个仓库, 但GitHub本身并没有提供这种功能. 如果用git命令未免有点麻烦.🔗GitZip允许我们一键下载一个文件夹为压缩包, 可以说是很便利了😃 侧边栏显示仓库文件树 在GitHub上想找一个文件只能一层一层文件夹点进去是一件令人十分苦恼的事, 而🔗Octotree能让我们像使用IDE一样在侧边栏看到文件树, 甚至是带图标的! 3D GitHub提交热力图 🔗 IsometricContributions纯碎是一个美化GitHub个人主页的贡献热力图的插件. 它会将Github Contributions Graph呈现为3D的柱状图. 非常炫酷😎 学术谷歌学术搜索 使用这个🔗 Google学术搜索按钮可以十分便利的搜索有关学术的内容. 一键跳转Sci-Hub Sci-Hub是一个emmm你们以后会知道的神仙网站, 🔗 AutoSci-Hub实现了一键从论文网页跳转Sci-Hub功能 💡 不过Sci-Hub上只有SCI的文章, 如果想下知网等国内文献数据库的文章, 只需连接校园网后再进入即可下载. 学校为大家购买了许多数据库 (具体哪些数据库大家可以到学校图书馆官网查看, 中外数据库都有), 可以免费下载各种文献👍 办公Office全家桶现在我来解说一下如何破解Office… 不,没这么麻烦, 电子科大为同学们提供了免费的正版Office! (甚至格院同学们可以享受高贵的Office365套装🐮🍺) 💡 上面这个链接只能通过校园网或者寝室WiFi登录. Office的激活需要通过学校提供的这个软件进行. 💡 顺带一提, 用学校邮箱 (学号@std.uestc.edu.cn)登录OneDirve (格院同学们也可以用格大学号@student.gla.ac.uk登录), 会惊喜的发现有2T的云空间! PDF阅读器实际上只是想看PDF的话你只需要有Chrome或者Edge这两个浏览器之一就可以了.我个人觉得chrome不适合拿来看pdf, 因为它看pdf的界面不好看😁 而用Edge看pdf甚至体验很良好, 打开速度快, 还能点右上角的笔图标来用OneNote做笔记. 也有很多人用的是老牌pdf阅读器Adobe Acrobat. 虽然Acrobat历史悠久, 但它的界面设计得很现代,很值得称赞的是它打开pdf的速度. 但是Adobe家的东西向来要钱, 想免费使用Acrobat那就得破解, 我觉得不如就用Edge了. 但是上述几款的问题在于他们并不能记忆阅读进度. 如果课件每次打开需要手动翻到讲到的地方我觉得还是挺麻烦的. 🔗 DrawboardPDF是我目前使用的pdf阅读器. 很不幸的是在我下载时还免费的这个软件现在要好几十了😁 不过这个软件能记忆阅读进度, 支持手写/触屏模式, 做笔记的方式甚至比OneNote还要丰富.如果你喜欢在pdf上手写笔记还是很推荐这款软件的. 写作文本编辑器🔗 不建议使用Windows自带的记事本 因为历史原因, Windows记事本会在文件最开头加一个BOM, 导致在某些情况下文本会被识别为乱码. 最受认可的记事本是🔗 notepad++, 它没有上面说这个毛病, 还有许多很实用的功能, 比如他能装插件, 比如基本所有语言的语法高亮 (在notepad中以HTML格式复制代码直接粘贴到word可以连语法高亮一起粘贴过去! 当然VSCode等编辑器一样能做到) Markdown要说写markdown那必然是🔗 Typora 这是一款所见即所得的跨平台Markdown编辑器. 极其美观, 能显示大纲, 能直接粘贴图片, 能迅速更换颜色主题,能显示数学公式, 能导出文件为HTML, PDF等. 总之写markdown认准typora! 💡 在typora的帮助一栏有markdown语法参考文档. PDF是的pdf也是可以编辑的, 只不过大部分软件不支持. 前面提到的Acrobat是可以编辑pdf的, 但我最推荐的方式是用Word打开编辑 (较老的版本不支持). 因为word学校免费提供了. Adobe全家桶以下是来自一个微信公众号的adobe全家桶安装和破解教程 🔗 Photoshop CC2019 🔗 Illustrator CC2019 🔗 Premiere Pro CC2019 🔗 After Effects CC2019 🔗 Audition CC2019 CADAutoCAD和SolidWorks是大学生最常接触到的CAD (计算机辅助绘图) 软件, 其中AutoCAD更多是用于绘制2D图纸, 而3D设计最常用的就是SolidWorks了. 🔗 AutoCAD 2020 🔗 SolidWorks 2016 💡 因为SolidWorks无法向上兼容 (低版本SW无法打开在高版本创作的工程), 考虑到用得最多的版本是2016, 此处也给出2016版的链接. 🔗 SolidWorks 2019 MATLAB好几个学院在高年级都会有用到MATLAB的课程, 但我自己是不甚喜欢MATLAB的. 从链接能看出MATLAB更多是工科生验证算法用的, 本身不算什么高明东西. (如果你有精力我推荐Python!) 不过MATLAB用鼠标点一点就能画出很直观的图, 工具集成度非常高这几点还是很不错的. 再怎么说学校说要用能有什么办法😁 👇 给非格院同学们的最新版MATLAB安装和破解教程 🔗 Matlab R2019a 而格院学子就很牛逼了, 有🔗 格大提供的免费正版MATLAB用! 不过说实话格院学费在那摆着, 并不会让人有占便宜的感觉🤷‍ 💡 MATLAB官网上说每个账号只能给一台设备激活MATLAB, 不过我看我激活了好几台一样都能用. 系统安装/维修工具系统启动盘烧录工具🔗 Rufus是功能最强大的系统启动盘烧录工具. 不管是Windows还是Ubuntu亦或是Arch, Raspbian… 通通都能烧录! 使用也十分简单, 通常只需选择要烧录到的移动储存设备和要烧录的镜像即可, 其他选项Rufus会自动识别该选什么. 💡 我在我的移动硬盘中收集了一些常用的镜像, 并放了一个便携版Rufus安装包在这个文件夹, 这样要烧录系统启动盘时我只需同时插上我的移动硬盘和要烧录系统的U盘就可以进行👍 PE盘什么是PE盘? Win PE, Windows预先安装环境 (英语：Microsoft Windows Preinstallation Environment) , 简称Windows PE或PE. 其实就是一个轻量版的Windows系统, 由于体积比较小, 可以直接存储在U盘或者移动硬盘上. 一般电脑维修人员使用其查找故障, 也是装机重要工具之一. 国内有许多PE工具, 比如老毛桃, 大白菜, 微PE等 我推荐🔗 优启通. 这个PE盘的工具很齐全, 界面也比较好看, 能兼容更新一些的windows系统. 数据恢复基本上出去修电脑说要恢复数据那修电脑的师傅就会打开🔗 DiskGenius一通操作, 然后如果还找不回来一般他就告诉你修不了了😁 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });]]></content>
      <categories>
        <category>科普</category>
      </categories>
      <tags>
        <tag>LeoJhonSong</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[灯泡的硬件入门]]></title>
    <url>%2F2019%2F09%2F01%2FGetting-Started-With-Hardware%2F</url>
    <content type="text"><![CDATA[因为有的小伙伴还想看硬件方面的入门，所以我就请了格拉斯哥学院电工专业的灯泡给大家写几句。 The words in front因为我们学院（格院）硬核专业课都在大三大四，所以我只能分享一点电子方面入门的经验，如果和我一样，之前没有接触过相关内容，可以参考我的分享，如果你之前已经有相关学习经历，可以找群里的宋姐姐，明佬，他们比我厉害得多。 The programming language硬件入门也要从C语言开始，只需要搞懂最基本的语法，会自己写代码即可。不建议看书，看了也会忘，而且很多内容用不上。不需要学算法。 The Single chip microcomputer对C了解一些了就可以学单片机了，选一款单片机开始入门，我是从arduino入门的，也有的是学51，或者32，我不会51，32所以没法讲。如果是学32的话可以问明佬，好像是从f系列开始学，我们院学的L系列，格院的朋友可以问高总或者我。 Arduino说一下arduino的好处，写起来基本和C一样，各种API包装好了可以直接调，就不用管很多配置的事情了，所以作为入门算是最简单的。成本上，不买原装进口的arduino就比较便宜，可以在淘宝上买套装，配好了一堆传感器，省了很多事情。 b站上能搜到arduino的入门教程，按着他教的开始就是跑各种传感器的程序，花式点灯什么的，主要了解一下数字和模拟I/O，pwm，串口调试。这些作为入门会玩的很开心的，真心觉得blink的成就感比print一个hello world要大。 Competition然后开学应该会有一个盟升杯的比赛，可以去摸鱼（抱大腿.jpg），可以学到电设比赛是怎么进行的，合作的比赛该怎么分工。 What’s more 在使用各种电子元件的时候，学习如何会看datasheet，主要看怎么接线，和一些要计算的相关参数 学会用多用电表和示波器检测电路 有兴趣还可以学焊板子，建模软件（solidworks cad），仿真软件（不是重点，但比赛可能会用到） 说一下我这一年接触EE的感觉吧。其实EE学的内容是真的杂，真的多，以上列举的都只是嵌入式的一点点入门，关于数字电路，模拟电路，信号系统之类的我都不懂，所以也讲不出来。 即使是学完了所有专业课，也远远不是EE的目的，EE的research可以各有领域，他会把你学的知识和其他学科进行结合，举例子我们在格拉斯哥大学听的那边做research的人在做的一些东西：比如生物医学里的仪器，激光应用，航天领域，机器人相关的东西，这些都是建立在EE的基础理论和应用上的，所以方向真的很多。 当然EE也有本身电子相关的方向，但那些我也不了解，你们可以找宋姐姐进行交流，他是我偶像。 如果你没有搞清楚自己想往哪个方面发展，那就把数理基础学好一点吧，基本学了的早晚会用上的。 EE的入门非常的玄学，你的电路时常会出一些老师都没法立刻给你答案的问题，需要你用多用电表一个一个排除，用示波器显示出来挨个的分析，这是一个十分耗费精力和兴趣的过程，所以一定要坚持下来啊！ 最后，欢迎加入微软学生俱乐部，这里有唱歌跳舞投资写代码都会的全才天乐姐姐，有可以给你画老婆的富婆部长严叔叔，带你唱歌喝酒蹦迪的社会高总，也有什么都不会但是可以帮你当电灯泡的我，还有各种各样超级nice的学长学姐。大家水群约饭，比赛还可以内部组队，共同努力和进步还是很开心的。 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });]]></content>
      <tags>
        <tag>灯泡</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Overview of Computer Science]]></title>
    <url>%2F2019%2F09%2F01%2FOverview-of-Computer-Science%2F</url>
    <content type="text"><![CDATA[有的同学表示对计算机有什么方向比较迷茫。应一些小伙伴要求，我就班门弄斧得给大家稍微介绍和总结一下。 专业计算机科研领域榜单-CSRankings首先你需要查看一个计算机学科排名的榜单，叫做CSRankings。这个榜单较为全面的展示了计算机学科的各个方向和排名。 虽然CSRankings有很多大学的信息并不完全，也因此被诟病，但是CSRankings是一个专门给大学的计算机学科排名的榜单。而且CSRankings的考量因素并不包括其他榜单考虑的很多较为难以量化和主观的因素，只考虑从一定角度来说，CSRankings做到了完全靠数据说话，完全客观。 感兴趣的同学可以看看电子科技大学在计算机领域的综合排名和各个细分方向排名是多少。 左边就是计算机的各个领域和细分方向了。 同学们就可以看看哪个方向你看上去比较感兴趣，然后 Google Scholar(谷歌学术)或者wiki(维基百科) 搜索一下，最好不要用中文搜索。因为在科研领域中，中文是没有地位的，资料非常不完善并且可能搜出来的东西完全是错的或者是歧义。 这里稍微歪下，稍微介绍下Google Scholar，它是谷歌的一个学术搜索引擎，也是最常用的学术资料搜索引擎，无论是搜索论文还是搜索机构，大学，教授都很方便，电子科技大学现在校园网已经可以不用翻墙就可以访问谷歌学术了。 计算机工程细心的同学会注意到“计算机科学与技术”专业代表了两个方向，即“科学”与“技术”。 那么我们大概了解了“科学”的方向都有了什么之后，就该了解一下工程界的计算机大概的方向了，也就是“技术”的部分。 前端我们知道构建一个app一般需要一个美观的界面，那么构建界面和UI的就是前端。 前端包括一些Web上的技术，也就是“写网页”。主要需要学习的是一些HTML，CSS，Javascript等等，还需要学习一些Javascript的框架，如React，Vue等。 关于Web的前端，w3cschool是个很好的学习资源网站。 还包括写一些软件的界面，主流的有Qt，Electron，微软家的UWP等等。 开发移动端的话就要学会一些安卓/iOS的开发技巧了，安卓用Java的比较多，iOS主要是Objective-C和Swift。 后端app只有界面不行，还得有功能，功能就需要有服务器和数据库等等的支持，负责这一部分的统称为后端。 可能要学的就是一些服务器和数据库相关的，服务器的话一般都用的Linux系统，所以一定要学会Linux的基本使用方法。 数据库类型就很多了，如MySQl，而且学校会开设数据库方面的专业课。 可能还需要学习一些算法知识（其实算法知识或多或少各方面都需要一些）。 但其实后端包含的面太广了，这里只是说了下典型。 算法比赛有ACM-ICPC和CCPC。详情可问小灰晖，同时第0次沙龙也有ACM-ICPC的入门介绍。 测试软件写出来直接运行可能会有bug，如果直接发布可能会有严重的后果，负责写程序对软件进行各项检查的就是测试。 下面这个表情包就大概能体现一个软件测试的各项工作了。 安全当然软件也需要专业的安全保障，对软件进行安全测试就是安全部门的工作了，传统的安全防护有对软件进行逆向工程（俗称“破解”）方面的保护，最近比较火的是网络安全，阻拦网络上的各种恶意攻击和病毒。 安全方面的工作涉及的知识覆盖密码学，web安全，二进制安全等等。 安全方面有知名的竞赛，其中一种比较火的就是CTF比赛。感兴趣的可以去了解一下。同时现在有全国大学生信息安全竞赛。 架构当然也会有一些人是负责总体设计的，他们一般被叫做架构师。 架构师需要深厚丰富的软件开发经验，可以说是软件的设计师。 What’s more实际上构建一个app可能会很复杂，上面的分法是很粗糙的，不同的软件公司和不同的软件都会有不同的开发团队组成。 有些比较赶新潮的公司就会有云技术，AI，大数据等部门。 这上面是说构建一个app，当然也存在构建一些所谓“基础设施”的，比如操作系统。 UESTC有什么方向？遗憾的是，我们学校计算机科学并没能实现所有方向全覆盖，在我个人看来甚至瘸腿。所以了解我们学校有什么方向就很关键了，因为如果你要本科从事科研相关活动的话就只能从他们中选了。 先来看一下我们学校计算机学院有什么科研团队。 细心的同学会发现你电计算机学院大部分教授都是做AI的，如果你在CSRankings上看过电子科大的各项排名，会发现我们学校计算机视觉（Computer Vision）方向排名非常突出，而计算机视觉是人工智能细分方向之一。 几乎所有科研团队都做CV，也造就了你电CV强校的事实，但也让你电计算机学科建设略显单一。不过我们也存在做云计算，网络安全，传统算法，操作系统等方向的实验室。 实际上最后最重要的是找哪个老师，这一点无论你是不是想从事计算机方向的科研都是一样的，所以要到电子科大教师信息平台去了解。 当然如果你想了解下这个老师最近在做什么方向的研究，或者看看他实力如何，是不是高产，你就可以用到上面我提到的Google Scholar了，直接搜这个老师，他的学术活动就一目了然了。 计算机学院的专业虽然我认为在电子科技大学，你在哪个专业并不特别影响你真正从事的方向，我认为这是电子科大非常好的一个地方，不过还是有很大的必要了解一下我们学校的专业设置和专业课程。 专业的课程设置要看《电子科技大学学生培养方案》，你们领了书的话应该有，是一大本很厚的书，找到自己学院然后看课程设置就是了。 如果还没拿到书可以到各个学院官网下载历年的培养计划。虽然每年培养计划都会有一点点改动。 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });]]></content>
      <tags>
        <tag>Luosuu</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[电子科技大学微软学生俱乐部2018企划]]></title>
    <url>%2F2018%2F08%2F16%2F%E7%94%B5%E5%AD%90%E7%A7%91%E6%8A%80%E5%A4%A7%E5%AD%A6%E5%BE%AE%E8%BD%AF%E5%AD%A6%E7%94%9F%E4%BF%B1%E4%B9%90%E9%83%A82018%E4%BC%81%E5%88%92%2F</url>
    <content type="text"><![CDATA[2018届主席团 2018年7月26日 “微软学生俱乐部”（Microsoft Student Club, 简称 MSC）是微软亚洲研究院与高校合作培养人才的一种探索。自 2000 年 10 月 15 日第一个俱乐部在四川大学成立起，至今全国已有34所高校拥有了自己的 MSC。俱乐部本着“学习先进技术，开拓创新思维，体验多元文化，成就一流人才”的宗旨，在各高校校团委、相关学院的指导下，通过学生项目、线上微课、产品体验、技术沙龙、学生大赛等活动，培养部员的创新头脑、实践能力和组织能力，让来自不同领域的同学得以展现才华，共同成长。电子科大微软学生俱乐部到目前为止已经走过16个年头，我们期待在新的一年遇见更好的你们。关于俱乐部的详细介绍可见： 新人技术培养计划 C/C++方向(推荐给萌新们，从零开始到熟练玩乐C++) Python方向(从零开始，快速玩转) Ps,AE等技术学习 前端开发组 //可能会有 C#方向(从零开始接触Windows应用开发) //可能会有 1.1 Q&amp;A Q：我不是计算机专业的什么都不会可以参加么？ A：俱乐部从来不局限于专业与基础只要你对技术感兴趣，新人培训完全是从零开始，请不要担心 Q：培训模式是什么样子？ A：技术培养主要精力放在线上，由技术负责人布置任务，新人根据人数分成小组，完成学习进度并进行代码提交，遇到的问题可以向技术负责人以及群里学长学姐询问。同时，小组根据进度至少每两周进行一次线下交流，组内沟通学习进度与出现的问题。学期末每个技术组需要完成一个小项目，作为年会时的展示，并对贡献度较大的成员进行奖励。 Q：我是文科生不会技术可以参与么？ A：俱乐部非常的欢迎具有写作和运营能力的同学。我们的微信公众号，网站都可以给你提供一个平台，供你发挥。 学术沙龙 一小时的科普活动 一小时认识入门计算机前沿领域 线上分享科技圈新消息，以及微软内部新技术 2.1 Q&amp;A Q：什么是前沿领域？ A：比如机器学习相关的自然语言处理，计算机视觉。强化学习，网络安全等 图书奖学金计划 俱乐部成员可向俱乐部申请图书奖学金，用与学习某项计算机相关专业技术。当申请者认真读完该书，并且通过写博客或者开小型talk的方式来证明已学到该书的知识之后，俱乐部将为其报销购书款项。由于事先我们签署过协议，这使得申请者更容易坚持把书认真读完，而不易半途而废。我们想达到的目的是激励俱乐成员进行学习，并且学有所成。 Special activity PPT脑洞创意赛 不论你是新生还是老油条，都会对于自己期待的生活有所向往。也许现在还没有成型的产品，那么请你和队友展示你们共同的愿景，让我们也体会这产品的有趣或实用或是艺术与美好的体现。 创新杯and微软校园菁英计划 俱乐部将会展开创新杯的宣传，欢迎俱乐部成员组队报名参加微软创新杯。从四川赛区走向全国总决赛，再到全球总决赛。希望电子科大的同学能够到达西雅图，代表UESTCer，书写自己的的传奇。 微软“编程之美” 俱乐部承担了编程之美比赛的宣传，也会组队进行比赛，领略微软的最新科技。比赛具有高额奖金，欢迎各位同学参与。 成都高校Hackathon 由电子科技大学和四川大学共同举办。一场24小时的头脑风暴与demo开发，俱乐部成员可自由进行组队，参与黑客马拉松活动。微软提供官方API和Azure云计算平台，参赛队用于专门的场地，享受俱乐部提供的餐点，零食，饮料，感受不同思想碰撞的的过程，开发的乐趣。参赛者有机会获得微软纪念T恤和奖金。 俱乐部内部的长期活动 人工智能与机器学习小组 参与人员以大二及以上同学为主。欢迎有技术基础以及对这个方向感兴趣的大一成员参与。活动形式以定期线下组会交流方式进行，交流学术圈、科研圈的内容，对论文进行讲述。 还可能玩什么 编程一小时活动 我们将会和周边的中小学进行互动，走进课堂，用有趣的方式(比如微软提供编程小游戏)给小朋友们提供一次编程入门体验 软粉聚会 你可以体验大家使用的SurfaceBook,SurfacePro,Xbox等产品。共同交(tu)流(cao)，享受软粉的快乐。 福利 微软学生夏令营 每年八月份，俱乐部可以推选优秀成员免费去北MSRA参与为期一周左右的夏令营。 【报销来回交通费用，四星级酒店，复式房型】以往经历参考：https://www.zhihu.com/question/31743851http://chuansong.me/n/2250686 日常活动和年会中的微软纪念品 活动限定T恤 office365全年订阅 星巴克联名杯 一系列神奇礼物 加入MSP计划，获得价值6W元的Visual Studio订阅 详见：https://msdn.microsoft.com/en-us/microsoftstudentpartners.aspx。俱乐部成员在申请MSP时将占巨大优势。电子科技大学这几年一共诞生了超过十名MSP。微软校园精英面向全球，不仅仅是计算机专业的学生，推广他的学生项目，让当代学生站在科技的前沿，领略科技的魅力，更希望他们能于其中，利用微软的技术，一起去改善生活，改变世界。无论是微软亚洲研究院下30多所高校的微软学生俱乐部，亦或者是全球范围内的 Microsoft Student Partner。加入MSP，你将获得更加开阔的眼界、认识来自全国乃至各高校的优秀同龄人、还有每年价值上万美元的MSDN订阅。 MSRA内推俱乐部中的成员，俱乐部可以给予亚研院的内推资格。微软亚洲研究院属于国内计算机领域顶尖的实习机构。关于亚研院的实习介绍可见：https://www.msra.cn/zh-cn/news/features/0cc4c253-ba4a-4dca-9604-51ec63e47232 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });]]></content>
      <categories>
        <category>管理层公告</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Hackathon参赛指南]]></title>
    <url>%2F2018%2F06%2F01%2FHackathon%E5%8F%82%E8%B5%9B%E6%8C%87%E5%8D%97%2F</url>
    <content type="text"><![CDATA[Hackathon顾名思义，其实就是黑客的马拉松或者编程马拉松——以电脑为跑道、以编程为体力的一场技术比赛。跟马拉松的精神很类似，黑客马拉松可以让很多不认识的人在一个特定的时间内相聚在一起，以他们想要的方式，去做他们想做的事情。对于程序员来说，Hackathon 绝对是一项激动人心的活动。那么第一次参加 Hackathon 的话，需要提前知道和准备些什么呢？参赛的时候又有哪些需要注意的事情呢？参加 Hackathon 会有什么收获呢？ Hackathon 的特点正所谓知己知彼，百战不殆。那么 Hackathon 有哪些特点呢？ 时间短：比如这次的 Hackathon 就只有 24 小时，除去吃饭和休息，留给大家开发的时间已经不多了。 强度高：开发过程中可能遇到各种各样的问题，这些问题都需要在短时间内快速解决，甚至还可能需要现学一门新技术新语言。总之，从 0 开始创造一个产品，时间短任务重，体力和脑力都需要爆发。 创造力：Hackathon 的精髓在于以自己想要的方式，去做任何自己想做的事情。不再受限于工作中的各种业务需求，用天马行空的脑洞，挑战已有的技术、理念，去创造新的产品，让世界变得更美好。 配合度：Hackathon 是一项团队赛，需要队员之间的积极配合和及时沟通，这是一场团战，参团协作很重要。切忌单打独斗。 Hackathon 可能会用到的工具：简单易用，你可能会用到。 微软各类认知服务API https://azure.microsoft.com/zh-cn/try/cognitive-services/ Azure云服务 注意事项0. 需要准备什么？带上你和你的电脑，准时参赛。1. 了解大赛规则• 不能违反的规则• 评分规则2. 找准定位，明确分工根据自己的专业技能和个人特长明确自己的定位，是队长还是队员？是开发还是产品？确定每个人的职责和目标，然后尽情地发挥所长吧。3. 合理分配资源，控制进度在比赛一开始就制定项目计划和开发流程很有必要。做什么不做什么，先做什么后做什么，什么时间节点应该完成什么功能等。4. 适当的休息体能的分配也很重要，所谓磨刀不误砍柴工，充足的精力才能在高强度的开发环境下完成任务，尽量做到按时吃饭和休息，记得多喝水。5. 快速迭代快速地完成第一个产品原型，然后再去增改其他功能。这个时候，代码优雅不优雅什么的就算了吧，先搞出来再说。6. 坚定目标，不忘初心比如遇到的困难太多，做着做着突然就不知道接下来该怎么办了，这个时候，一定要坚持！7. 善于求助搞不定的部分要尽快向队友甚至别的团队求助，千万不要不好意思，团队之间不完全是竞争关系，也可以互相合作。8. 产品演示酒香也怕巷子深，好的产品介绍很重要。真诚地向大家表达你们的想法，展示你们的成果。另外一份漂亮的 PPT ，一个好的讲演人总是更能吸引人。 Hackathon 的收获1. 认识大牛同来参赛的开发者中，可能是acm大佬，可能是国奖得主，可能是论文在手的磕盐党，也可能是设计出好看ui的美工大大，亦或是能够根据想法作出近趋完美presentation的讲演者。2. 做点好玩的东西繁复的敲击工作，作业工作的需求，对于 coding 已经失去了最初的乐趣。那么这一次，你说了算！去做一个在你心目中真正想做的产品吧。3. 一次难得的经历彼时热血方刚，挥斥方遒，手指与键盘共舞，代码与 idea 齐飞。将来的某一天回忆起来，这绝对是一场值得你怀念的经历。 最后的最后，Hackathon 是一种乐趣，而不是一个死气沉沉的编程比赛，让我们尽情地享受它吧。Just enjoy it! document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });]]></content>
      <categories>
        <category>活动</category>
        <category>Hackathon</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[【创新杯】2018创新杯宣讲会·电子科大站]]></title>
    <url>%2F2017%2F12%2F02%2F%E3%80%90%E5%88%9B%E6%96%B0%E6%9D%AF%E3%80%912018%E5%88%9B%E6%96%B0%E6%9D%AF%E5%AE%A3%E8%AE%B2%E4%BC%9A%C2%B7%E7%94%B5%E5%AD%90%E7%A7%91%E5%A4%A7%E7%AB%99%2F</url>
    <content type="text"><![CDATA[2017年12月1日，俱乐部与微软成都合作举办了微软创新杯2018年的宣讲会。 来自微软的技术人员首先介绍了微软的AI技术，包括Cognitive Service，Bot Framework，以及Azure Machine Learning. 在场同学积极参与宣讲，现场气氛非常热烈。 图为积极回答问题的同学。 图为技术人员介绍报名通道。 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });]]></content>
      <categories>
        <category>活动</category>
        <category>创新杯</category>
      </categories>
      <tags>
        <tag>张逸霄</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【给萌新的Python】OOP基础]]></title>
    <url>%2F2017%2F11%2F18%2F%E3%80%90%E7%BB%99%E8%90%8C%E6%96%B0%E7%9A%84Python%E3%80%91OOP%E5%9F%BA%E7%A1%80%2F</url>
    <content type="text"><![CDATA[什么是OOP？ 面向对象程序设计（英语：Object-oriented programming，缩写：OOP）是種具有物件)概念的程式編程典範，同时也是一种程序开发的抽象方针。它可能包含資料、屬性、程式碼與方法)。对象則指的是类)的实例。它将对象)作为程序的基本单元，将程序和数据封装)其中，以提高软件的重用性、灵活性和扩展性。 面向对象程序设计可以看作一种在程序中包含各种独立而又互相调用的对象的思想，这与传统的思想刚好相反：传统的程序设计主张将程序看作一系列函数的集合，或者直接就是一系列对电脑下达的指令。面向对象程序设计中的每一个对象都应该能够接受数据、处理数据并将数据传达给其它对象，因此它们都可以被看作一个小型的“机器”，即对象。 简而言之，对象就是把程序的一些函数分类进行了整合，使之更加明确灵活。 下面结合例子来讲述OOP。 假设我们去银行取钱，那么流程大概是这样的： ATM机发起请求，后台接受请求并返回交易码，ATM机提示输入密码，将密码发送给后台，后台验证之后返回结果，ATM机取出现金，向后台发起记录请求，后台更新账户信息，并且增加交易记录，用户取钱。 在这个流程中我们牵涉到了四个实体：人类，ATM机，后台，账户。 ATM机负责一系列操作，后台负责另外一些操作，对象和对象之间可以相互交流信息，同时又各司其职。 基于这样思想的编程，成为面向对象的编程。现在我们来看一个编程上的实例： 学生有语文、数学、英语成绩，有学号和姓名，还需要一个相关的函数来计算他的总分。 分析下来，我们可以构建出一个学生类。 这个类，拥有一些属性：语文、数学、英语，学号、姓名，还拥有一个方法：计算成绩。 这个框架定下来之后，我们就构建好了一个类。将这个类实例化，比如一个叫小明的同学，就是一个对象。对象和类是抽象和具体的关系，类是抽象的，是一类事物将特征提取出来的概括性的描述，而对象是具体到了某一个事物。 现在我们来构建这个类： 类有两种成员：属性和方法。 class后面紧接着是类名，即Student，类名通常是大写开头的单词，紧接着是(object)，表示该类是从哪个类继承下来的，继承的概念我们后面再讲，通常，如果没有合适的继承类，就使用object类，这是所有类最终都会继承的类。 由于类可以起到模板的作用，因此，可以在创建实例的时候，把一些我们认为必须绑定的属性强制填写进去。通过定义一个特殊的__init__方法，在创建实例的时候，就把name，score等属性绑上去： 在C++中，这个方法被称为“构造函数”，在初始化一个对象的时候，要用一些必要的参数才能将其实例化。因为Python是动态语言，你也可以自由地设定类的属性。 注意到__init__方法的第一个参数永远是self，表示创建的实例本身，因此，在__init__方法内部，就可以把各种属性绑定到self，因为self就指向创建的实例本身。 有了__init__方法，在创建实例的时候，就不能传入空的参数了，必须传入与__init__方法匹配的参数，但self不需要传，Python解释器自己会把实例变量传进去。 和普通的函数相比，在类中定义的函数只有一点不同，就是第一个参数永远是实例变量self，并且，调用时，不用传递该参数。除此之外，类的方法和普通函数没有什么区别，所以，你仍然可以用默认参数、可变参数、关键字参数和命名关键字参数。 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });]]></content>
      <categories>
        <category>Python</category>
        <category>OOP</category>
      </categories>
      <tags>
        <tag>张逸霄</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【给萌新的Python】大作业（1）&补充知识]]></title>
    <url>%2F2017%2F11%2F01%2F%E3%80%90%E7%BB%99%E8%90%8C%E6%96%B0%E7%9A%84Python%E3%80%91%E5%A4%A7%E4%BD%9C%E4%B8%9A%EF%BC%881%EF%BC%89%26%E8%A1%A5%E5%85%85%E7%9F%A5%E8%AF%86%2F</url>
    <content type="text"><![CDATA[布置大作业前，我希望介绍两个结构进行扫尾。 1，列表生成式。 什么是列表生成式呢，简而言之就是，你可以将for循环用一种更为简练的方式表达出来，最后你可以得到一个列表。 举个例子，要生成list [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]可以用list(range(1, 11))， 但如果要生成[1x1, 2x2, 3x3, ..., 10x10]怎么做？方法一是循环： 更简单的方法则是使用列表生成式。 如果循环体非常简单，那么这个方法将会相当有效。 另外，因为Python的for循环可以同时迭代多个变量。比如dict的items()可以同时迭代key和value： 12&gt;&gt;&gt; d = {'x': 'A', 'y': 'B', 'z': 'C' }&gt;&gt;&gt; for k, v in d.items(): 2，迭代器： 通过列表生成式，我们可以直接创建一个列表。但是，受到内存限制，列表容量肯定是有限的。而且，创建一个包含100万个元素的列表，不仅占用很大的存储空间，如果我们仅仅需要访问前面几个元素，那后面绝大多数元素占用的空间都白白浪费了。 所以，如果列表元素可以按照某种算法推算出来，那我们是否可以在循环的过程中不断推算出后续的元素呢？这样就不必创建完整的list，从而节省大量的空间。在Python中，这种一边循环一边计算的机制，称为生成器：generator。 生成器的最显著特点是即时演算。 要创建一个generator，有很多种方法。第一种方法很简单，只要把一个列表生成式的[]改成()，就创建了一个generator： 123456&gt;&gt;&gt; L = [x * x for x in range(10)]&gt;&gt;&gt; L[0, 1, 4, 9, 16, 25, 36, 49, 64, 81]&gt;&gt;&gt; g = (x * x for x in range(10))&gt;&gt;&gt; g&lt;generator object &lt;genexpr&gt; at 0x1022ef630&gt; 创建L和g的区别仅在于最外层的[]和()，L是一个list，而g是一个generator。 generator保存的是算法，每次调用next(g)，就计算出g的下一个元素的值。 试一试，创建一个生成器，然后不断调用它。 希望你已经试过了。亲手进行练习非常重要，希望你能重视起来。 当然，我们实际使用的时候，很可能也是用for循环去生成每一个元素。 那么第二种方法生成generator呢？当生成器不方便用列表推导式表示怎么办呢？ 如果一个函数定义中包含yield关键字，那么这个函数就不再是一个普通函数，而是一个generator： 1234567def fib(max): n, a, b = 0, 0, 1 while n &lt; max: yield b a, b = b, a + b n = n + 1 return 'done' 这个函数的yield的意思是：你的函数开始执行，碰到yield的时候返回一个值。再次调用这个函数的时候，从yield这里继续运行（而不是从头）。在这个函数里，我们先初始化了变量，然后进入循环。第一次循环内，返回了b；再一次调用函数时，是从第一次循环开始的，继续执行第一次循环，循环到第二次，yield返回值…… 3，迭代器 可以被next()函数调用并不断返回下一个值的对象称为迭代器：Iterator。 生成器都是Iterator对象，但list、dict、str虽然是Iterable，却不是Iterator。 你可能会问，为什么list、dict、str等数据类型不是Iterator？ 这是因为Python的Iterator对象表示的是一个数据流，Iterator对象可以被next()函数调用并不断返回下一个数据，直到没有数据时抛出StopIteration错误。可以把这个数据流看做是一个有序序列，但我们却不能提前知道序列的长度，只能不断通过next()函数实现按需计算下一个数据，所以Iterator的计算是惰性的，只有在需要返回下一个数据时它才会计算。 Iterator甚至可以表示一个无限大的数据流，例如全体自然数。而使用list是永远不可能存储全体自然数的。 大作业： 作业目标：实现基于爬虫数据的数据统计 1，二选一：requests+beautifulsoup或者scrapy爬虫框架。一般来说爬虫框架都是更好的选择，但是相对比较难上手。 2，爬取“豆瓣电影Top 250”页面，并且适当清洗数据格式，将其保存到本地。 3，使用正则表达式（需要一些简单的学习），提取所有电影的年份、国籍； 一个小工具：http://tool.oschina.net/regex 4，进行合适的统计（最好使用pandas等数据分析库，推荐学习），自定分析方法，得出至少三个有用的结论（比如说这些电影最多出现在什么年间，什么国家上榜最多） 加分项： 1，使用了scrapy爬虫框架； 2，分析了超过三项结论（比如说根据词频判断电影类型） 一些说明： 这个大作业希望各位在11月20日之前完成，期间我们还会讲新的知识。 善用搜索引擎，这些Python库都有完整的中文文档。 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>张逸霄</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【给萌新的Python】练习（1）]]></title>
    <url>%2F2017%2F10%2F21%2F%E3%80%90%E7%BB%99%E8%90%8C%E6%96%B0%E7%9A%84Python%E3%80%91%E7%BB%83%E4%B9%A0%EF%BC%881%EF%BC%89%2F</url>
    <content type="text"><![CDATA[在第一次线下沙龙时，我们讨论了Python的基本语法。我们尤其讨论了一些特别的数据类型：列表、元组、字典、集合。我们还讨论了基础的方方面面。接下来我想请各位按照之前分好的小组做完下列习题： 一、请按以下步骤完成Python指令（25分）： 1，新建一个列表。 2，在列表中依次添加两个元素：1，1 3，根据斐波那契数列的生成规律，在列表中再添加7个元素。（提示：可以使用for循环） 4，将列表倒序打印出来。 二、请按以下步骤编写Python文件（25分）： 1，新建一个文本文件并打开。 2，生成一个5*1的列表，储存以下矩阵：A=[1,5,6,6.5,8] 3，生成一个1*5的列表，储存以下矩阵：B=[2,4,10,12,5.5] 4，计算AB，A点乘B，A+B，A-B。 5，将上述结果逐行写入文本文件并保存。 三，请按以下步骤编写Python文件（15分）： 1，新建一个列表。 2，摇100次骰子，记录值。 3，将平均值、中位数、众数写进列表。 四，请按以下步骤编写Python文件（15分）： 1，有如下值集合 v1 = [11,22,33,44,55,66,77,88,99,90]，将所有大于 66 的值保存至字典的第一个key中。 2，将小于 66 的值保存至第二个key的值中。即： {‘k1’: 大于66的所有值, ‘k2’: 小于66的所有值}v2 = {‘k1′: [],’k2’:[] } 五，请按以下步骤编写Python文件（20分）: 1，已知ex可以用多项式逼近：ex = 1+x+x2/2!+…+xn/n!，请计算n=10，100，1000时的具体数值。 2，使用input函数输入n，要求输出一个正确的值。 以上问题拿到80分以上视为合格。请在一周内完成任务。 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>张逸霄</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[在Azure上部署TensorFlow（转载）]]></title>
    <url>%2F2017%2F10%2F01%2F%E5%9C%A8Azure%E4%B8%8A%E9%83%A8%E7%BD%B2TensorFlow%EF%BC%88%E8%BD%AC%E8%BD%BD%EF%BC%89%2F</url>
    <content type="text"><![CDATA[Training neural networks (deep learning) is very compute-intensive. Fast GPUs can make those sessions, which sometimestake hours, days or weeks go orders of magnitude faster. However, laptops usually don’t come with the fastest GPUs and havingto maintain a desktop machine only to occasionally run deep learning tasks is extra hassle. Cloud providers now offer virtual machines (VMs) with GPUs which run in data centers and can be used by anybody on an hourly basis.Below is a quick tutorial that walks through setting up a VM in Microsoft Azure with the necessary driversto train neural networks using TensorFlow. First, if you haven’t done so already, create an Azure account, install the Azure 2.0 command line interface (CLI)… 1sudo pip install azure-cli … and follow the login procedure: 1az login Azure manages resources (virtual machines, storage etc.) via resource groups.GPU virtual machine instances are currently available in the East US region. If you already have a group for that region feel freeto use it, otherwise create a new resource group: 1az group create -n tensorflow -l EastUS We will connect to the machine via SSH and need to create a key pair: 1ssh-keygen -f ~/.ssh/tensorflow_id_rsa -t rsa -b 2048 -C '' -N '' Next, we create the actual virtual machine running Ubuntu 16.04.We choose the cheapest and least powerful GPU size (NC6) and downgrade from premium (SSD) to standard storage (HDD) as the former is not supported for NC instances yet. 1az vm create -g tensorflow -n tensorflow --image Canonical:UbuntuServer:16.04-LTS:latest --size Standard_NC6 --storage-sku Standard_LRS --admin-username tensorflow --ssh-key-value ~/.ssh/tensorflow_id_rsa.pub Once completed, the command will print the IP address for the newly created machine: 1234{ "publicIpAddress": "127.0.0.1", "resourceGroup": "tensorflow"} The VM is now running in a data center (and charging for cycles).The following commands can be used to deallocate and restart anytime: 12az vm deallocate -g tensorflow -n tensorflowaz vm start -g tensorflow -n tensorflow Connect to the machine via SSH (type ‘yes’, if asked to continue): 1ssh tensorflow@$(az vm show -d -g tensorflow -n tensorflow --query "publicIps" --o tsv) -i ~/.ssh/tensorflow_id_rsa Install CUDA 8.0Next, download CUDA, make it known to apt-get and run install: 12345wget https://developer.nvidia.com/compute/cuda/8.0/prod/local_installers/cuda-repo-ubuntu1604-8-0-local_8.0.44-1_amd64-debsudo dpkg -i cuda-repo-ubuntu1604-8-0-local_8.0.44-1_amd64-debsudo apt-get updatesudo apt-get install -y cudarm cuda-repo-ubuntu1604-8-0-local_8.0.44-1_amd64-deb Now we can check the status of the GPU(s) by running nvidia-smi. Install CuDNN 5.1Next, download and install cuDNN… 1234wget http://developer.download.nvidia.com/compute/redist/cudnn/v5.1/cudnn-8.0-linux-x64-v5.1.tgzsudo tar -xzf cudnn-8.0-linux-x64-v5.1.tgz -C /usr/localrm cudnn-8.0-linux-x64-v5.1.tgzsudo ldconfig Environment variables…and add the following exports to ~/.bashrc: 123export CUDA_HOME=/usr/local/cuda-8.0export PATH=${CUDA_HOME}/bin:${PATH}export LD_LIBRARY_PATH=${CUDA_HOME}/lib64:/usr/local/cuda/lib64:${LD_LIBRARY_PATH} Install TensorFlowThe final step is to install Pip and the GPU version of TensorFlow: 12sudo apt-get install -y python-pip python-devsudo pip install tensorflow-gpu We can now start a Python console and create a TensorFlow session: 123python&gt;&gt;&gt; import tensorflow as tf&gt;&gt;&gt; session = tf.Session() If everything went well, it will recognize the Tesla K80 GPU: 1234567I tensorflow/core/common_runtime/gpu/gpu_device.cc:885]Found device 0 with properties: name: Tesla K80major: 3 minor: 7 memoryClockRate (GHz) 0.8235pciBusID b0b5:00:00.0Total memory: 11.17GiBFree memory: 11.11GiB Remember to deallocate the VM when done to avoid using cycles: 1az vm deallocate -g tensorflow -n tensorflow Once no longer needed, you can delete the virtual machine by running: 1az vm delete -g tensorflow -n tensorflow document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });]]></content>
      <categories>
        <category>AI</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[【谷哥的C/C++（2）】变量，数组，指针，结构体]]></title>
    <url>%2F2017%2F09%2F26%2F%E3%80%90%E8%B0%B7%E5%93%A5%E7%9A%84C-C%2B%2B%EF%BC%882%EF%BC%89%E3%80%91%E5%8F%98%E9%87%8F%EF%BC%8C%E6%95%B0%E7%BB%84%EF%BC%8C%E6%8C%87%E9%92%88%EF%BC%8C%E7%BB%93%E6%9E%84%E4%BD%93%2F</url>
    <content type="text"><![CDATA[逸霄说在前面的话：为了缓和谷哥的学习曲线，建议搭配《C Primer Plus》进行学习，同时我会搭配一些轻松愉快的小练习，供大家玩耍。本篇教程大概需要花费各位两个星期的时间进行完全的消化理解。 久违的第二次C语言教程又要开始了~在这之前，我在第一期教程中带着大家弄出了第一个程序。然后给出了几个需要自学才能完成的题目。不知道大家有没有努力自学并且完成呢。如果你还没有开始自学，那么，在阅读以下内容之前，请保证对C语言的以下相关部分的了解：了解基本的变量类型（int ,char ,float ,double）的基本含义运算符的简单使用（加减乘除，取地址解引用，自增自减，逻辑判断）简单的语法（顺序，判断，循环结构）常用的函数的用法（printf , scanf） 这些内容的学习还是比较轻松的，通过书籍与在线文档/搜索引擎很快就能完成。 （来自逸霄的唠叨：我知道这可能有些难度，尤其是输入输出需要多加练习。在编程的初期，你可能会遇到很多各种各样的bug，可能是因为你还没有太熟悉C语言的编程模式。欢迎你在群里询问。） 为了确认你认真的阅读了第一期教程，我们来做个热身。 热身 打开你喜欢的IDE或者文本编辑器，随手写一个打印九九乘法表的小程序出来，结果应该像这样： （逸霄的提示：首先你需要考虑一下怎么控制一样的宽度；然后你可能要写一个嵌套的for循环。如果你无法顺利完成这一步的话，意味着你还不能看第二讲，请使用一个星期的时间好好学习一下循环、条件这几大语法。这些并不难，只要好好写写小代码，就没有问题了。） （逸霄的唠叨：关于解引用这一块，你只要明白，在变量前面加上&amp;号，就代表取地址，比如说b=&amp;x;就代表着b被赋值了x的地址。而反过来，x与*b是一样的，如果我们在地址/指针前面加上*号，那么指的就是一个对象。更多的消息请看这里：http://blog.csdn.net/synapse7/article/details/10260339） 如果你感觉上面的小程序太小儿科了，那真是太好了。我也并不想在验证你的水平上浪费太多时间。 本期的教程的主题是 变量，数组，指针，结构体。在我们的仅有的基础上讲解C语言的各种数据类型。接下来我们步入正题。 一，为什么要有那么多数据类型？刚刚当你打印九九乘法表的时候应该用了整型变量。遇到一些其他的计算问题，比如说计算商品折扣后的价格时又用了浮点类型。如果你仔细的想一想，发现用浮点类型计算只需要使用整数类型的变量时好像也没什么问题。那么C语言为什么要存在这么多数据类型?储存数字不是只需要一个浮点类型就好了吗？ （来自逸霄的唠叨：如果你写python，你会发现浮点类型被广泛应用；另外关于浮点类型的存储方式，可以参见IEEE 754标准。这将会在计算机组成原理中被系统地学到。二进制浮点数地存储并不是很精确，所以时常会出现微小的误差。） 各种不同的数据类型出现的根本原因在于，计算机的储存空间和计算能力并不是无穷无尽的。如果你是一个单机游戏爱好者，肯定会知道，许多大型游戏需要计算机的内存，CPU，显卡等达到一定标准才能玩。如果你是更高级的游戏发烧友，可能还会听说什么游戏优化做的好，什么游戏特别烧显卡等。其实这就和我们今天要讲的话题有很大关系。 深入的了解计算机底层的知识，你会了解，整数运算的速度和浮点运算的速度不相同。整数与浮点类型占用的内存空间也是不相等的。我们不讨论计算机计算能力的无聊话题。变量所占用的内存空间可以通过C语言中一个看起来像函数的运算符sizeof求出，大概像这样： 亲自动手看看，sizeof会输出类型占用的字节长度值得一提的是，C语言中除了char这个最小的类型之外，类型的字节长度并不是一定的，这与使用的编译器以及平台有关。具体的原因在这里我们不做讨论，其实在一些底层的技术，以及开发平台无关的应用上了解这些还是相当重要的。但是这不是我们今天的主菜。 如果你需要做OJ，或者说为了考试，多上网了解一些这方面的知识。 二，数组数组简单的讲就是许多同类型的变量放在一起。比如一个程序需要储存一个名字，这就需要一个字符数组。char ch='G';char name[]="GYQ"; （来自逸霄的唠叨：在一些特殊的情况下，你也可能看到数组的元素是数组，这种情况在C#中被称为交错数组。）关于数组的初始化，赋值操作可以去看看书，文档，查查百度。 （来自逸霄的唠叨：这一块请务必不要跳过。关掉博文，去看一看书吧！）值得注意的是字符串的末尾有一个看不见的终止符。字符串”GYQ”由’G’，’Y’，’Q’，’\0’四个字符串组成，’\0’是空字符。没有了解的同学迅速去百度一波。 （来自逸霄的唠叨：也许你之前已经看过了类似\n, \r这样的表示方法，这些叫做转义字符。转义字符一般在你的C语言书中会有一个比较完整的表格，一般情况下只需要使用\n, \t这两种。如果你使用的教材是《现代方法》，你就会发现转义字符，编者是慢慢介绍的。） （事实上，每一串字符串，背后都会接一个空字符，代表这个字串已经结束了。更多的讨论请看这里：http://blog.csdn.net/supreme42/article/details/7300451，如果你不明白，请**不要跳过**这一段。） 数组还有维数这个说法。比如说，你在做线性代数的…呸。。。我们换一个轻松的话题。你在做一个贪吃蛇的小游戏，需要用一个变量来储存画面，最可能的就是一个二维的字符数组了。 所有的多维数组都能转化为一维数组int a[3][3]={{1,2,3},{4,5,6},{7,8,9}};int b[9]={1,2,3,4,5,6,7,8,9}; （横向存储的二维数组）转化方式就像上面那样，实际上多维数组与一维数组在计算机上的储存方式是一样的，也就是说上面那两个数组里面的数据的储存方式完全一致，多维数组的使用完全是为了更简单的逻辑表达。比如说我上面提到的贪吃蛇小游戏，用二维数组储存地图可以方便的使用两个索引值表示几行几列：map[5][3];//第6行4列如果是一维数组：map[5*LINEWIDTH+3]//看起来就像这样 关于数组的一些复杂语法在文末附有博客。 （逸霄的唠叨：如果学完这些你感觉有些吃力的话，你可以试试看在二维数组上嵌套for循环，来锻炼自己的能力。接下来是一个小小的练习：） 逸霄的小练习 请你设计一个井字棋游戏。井字棋可能长这样： 要点：正确使用二维数组打印棋盘；判断胜利条件。 这个程序可能需要你一至两小时完成，并花费一下午的时间进行debug。但是一旦完成了这个训练，你将会明白之前学的那些东西如何贯穿到一起来。 三，指针许多人都说指针是C语言里面最难学的地方，因为指针运算牵扯到太多的知识。就考试而言的确如此。但实际上，普通的指针应用并不是十分复杂。对于一个仅仅使用C/C++进行软件开发的人，因为有各种方便的东西可以使用。也许他所用到的东西就只有这个：/*C*/SomeType *a=(SomeType*)malloc(sizeof(SomeType));a-&gt;dosomething();.../*C++*/SomeType *a=new SomeType();a-&gt;dosomething();... 以上就是为一个类(结构)进行动态内存分配声明一个实例。注：malloc是C语言用于动态内存分配的函数，参数是类型的字节长，可以直接使用sizeof运算符计算。有关指针运算的部分，在实际应用中，大多可以使用数组下标的方法代替。 当然指针的用处并不只有这个指针是C语言中极其精髓的东西，关于指针的使用，运算规则可以查阅书籍，自行百度。 参考网站：http://www.runoob.com/cprogramming/c-pointers.html （来自逸霄的唠叨：指针是一个庞杂的话题。在《现代方法》中，有关指针的话题聊了整整两章。我们也无法在线上课程里详细地说明，但是我们可以进行一些针对性的提点。希望你在阅读下面的模块前，已经看过了教材对应的部分。你可能一时间弄不懂全部。没关系，之后我们用得多了自然就会熟练的。） 逸霄的Tips： 1，指针是一个变量，其值为另一个变量的地址，即，内存位置的直接地址。就像其他变量或常量一样，您必须在使用指针存储其他变量地址之前，对其进行声明。 2，使用指针时会频繁进行以下几个操作：定义一个指针变量、把变量地址赋值给指针、访问指针变量中可用地址的值。这些是通过使用一元运算符 * 来返回位于操作数所指定地址的变量的值。 3，在变量声明的时候，如果没有确切的地址可以赋值，为指针变量赋一个 NULL 值是一个良好的编程习惯。赋为 NULL 值的指针被称为空指针。 4，我们喜欢在程序中使用指针代替数组，因为变量指针可以递增，而数组不能递增，因为数组是一个常量指针。（实际上如果你尝试着将数组名当作指针使用，你会发现数组名指向了数组的第一个元素。） 逸霄的Tips： 为什么说指针是C语言的精髓？（https://www.zhihu.com/question/20125963） 除去知乎dalao们回答的这些以外，我想特意指出的是，C语言是一门强大的语言，但也是一门很精炼（简陋）的语言。它没有繁多的语法糖，如同一把中国厨刀，什么都能做。与之相比，C#、Java更像是厨师机，而Python更像是一套厨刀。拥有了很多绝妙的语言特性之后，指针的存在感将会被弱化。但是不得不说，指针的使用充满了技巧。 四，指针与数组指针与数组的复合运算，以及语法基本上算是C语言考试题中最高难度的东西了。这里推荐几篇博客：指针数组与数组指针：http://www.cnblogs.com/Romi/archive/2012/01/10/2317898.html二维数组和指针：http://blog.csdn.net/iu_81/article/details/1782642 逸霄的Tips： 整个一套学下来，你可能对C的整体有了一些把握。指针需要学通是一件长期而艰苦的事情，很多人一直学不会，于是便有了其他语言（比如C++实际上削弱了指针）。如果你实在无法熟练操作指针，没关系，至少概念要明白——我们为什么需要指针，指针的工作原理是什么，我们可以透过指针做些什么。 五，结构体 因为出现事故，这里贴个博客：http://blog.csdn.net/huqinwei987/article/details/23625823 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });]]></content>
      <categories>
        <category>C/C++</category>
      </categories>
      <tags>
        <tag>张逸霄</tag>
        <tag>谷亚奇</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【给萌新们的Python】理解输入和输出]]></title>
    <url>%2F2017%2F09%2F23%2F%E3%80%90%E7%BB%99%E8%90%8C%E6%96%B0%E4%BB%AC%E7%9A%84Python%E3%80%91%E7%90%86%E8%A7%A3%E8%BE%93%E5%85%A5%E5%92%8C%E8%BE%93%E5%87%BA%2F</url>
    <content type="text"><![CDATA[回到之前那个Hello World程序来。 如果我们使用文本编辑器（如Spyder，Atom，VS Code，Sublime）编写程序，那么这个程序要怎么运行的好呢？ 我们首先编写一个这样的程序。打开Visual Studio Code，首先安装python插件，这个插件可以很好地帮助我们写Python代码。 之后我们ctrl+N新建一个文件，编写代码，按下ctrl+S，以python文件形式保存。 于是我们得到了hello.py. 之后打开cmd，这样运行程序。 执行的指令是：python hello.py 回到正题，在这个程序里面，什么是输入，什么是输出？ 在console里，我们使用了print()函数，括号里面的是输入，返回的值就是输出。 现在我们尝试一个这样的代码： 理所当然地，它会返回300.在这里的输入是100+200，而输出是300.当然print()函数接受多个输入，只要加入逗号就可以了： 我们再看另外一个函数，input()。input()是最典型的输入函数。现在我么认识一个符号： = =可以将=右边的值赋值到=左边去。比如：x=300，这样你就将300赋值到了x上。 接下来我们尝试这么做： 我们成功地完成了一次输入。input里面可以填写参数，比如： 显示出了一些与输入有关的提示符。 接下来，我们将输入输出函数组合成一个程序： \n是换行符，请将它放进字符串里，因为\n本身是一个和单词一样的特殊字符。 这样，我们终于写出了一个与用户可以交互的程序了。 tips：sss 1，eval()函数代表，执行括号里面的句子。比如说eval(2300)，会返回这个算术的值。*你可以用这个函数，一行代码写一个计算器。 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>张逸霄</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【给萌新们的Python】相关环境，以及Python的hello world]]></title>
    <url>%2F2017%2F09%2F23%2F%E3%80%90%E7%BB%99%E8%90%8C%E6%96%B0%E4%BB%AC%E7%9A%84Python%E3%80%91%E7%9B%B8%E5%85%B3%E7%8E%AF%E5%A2%83%EF%BC%8C%E4%BB%A5%E5%8F%8APython%E7%9A%84hello%20world%2F</url>
    <content type="text"><![CDATA[各位萌新们大家好啊！这里是划水主席逸霄。根据我们之前约定的培养计划，我现在要写第一课了。 Python是一门怎样的语言？ Python是一门非常流行的解释型高级语言。现在，全世界差不多有600多种编程语言，但流行的编程语言也就那么20来种。如果你听说过TIOBE排行榜，你就能知道编程语言的大致流行程度。 总的来说，这几种编程语言各有千秋。C语言是可以用来编写操作系统的贴近硬件的语言，所以，C语言适合开发那些追求运行速度、充分发挥硬件性能的程序。而Python是用来编写应用程序的高级编程语言。 当你用一种语言开始作真正的软件开发时，你除了编写代码外，还需要很多基本的已经写好的现成的东西，来帮助你加快开发进度。比如说，要编写一个电子邮件客户端，如果先从最底层开始编写网络协议相关的代码，那估计一年半载也开发不出来。高级编程语言通常都会提供一个比较完善的基础代码库，让你能直接调用，比如，针对电子邮件协议的SMTP库，针对桌面环境的GUI库，在这些已有的代码库的基础上开发，一个电子邮件客户端几天就能开发出来。 Python就为我们提供了非常完善的基础代码库，覆盖了网络、文件、GUI、数据库、文本等大量内容，被形象地称作“内置电池（batteries included）”。用Python开发，许多功能不必从零编写，直接使用现成的即可。 除了内置的库外，Python还有大量的第三方库，也就是别人开发的，供你直接使用的东西。当然，如果你开发的代码通过很好的封装，也可以作为第三方库给别人使用。 Python的主要优点是：简单、适合快速开发。 Python的主要缺点是：慢、保密性差。 有关Python的介绍，请看廖雪峰的相关文章：Python简介 如何安装Python呢？ 首先这里默认你使用了Windows系统。我们首先打开Python官网：https://www.python.org/ 之后找到32位或者64位的版本进行下载就好了。注意关于Python的版本号选择，因为Python3已经具有广泛的应用，是Python的现在和未来。所以本教程将会立足于Python3来进行讲述。请各位下载Python3的最新版本：Python 3.6.2. 在安装的时候，请勾选：Add Python to path这一项，即将Python加入到环境变量。当然之后手动操作也是没问题的。这样配置的好处是，你可以直接在cmd，Powershell里启用Python. 当我们编写Python代码时，我们得到的是一个包含Python代码的以.py为扩展名的文本文件。要运行代码，就需要Python解释器去执行.py文件。 由于整个Python语言从规范到解释器都是开源的，所以理论上，只要水平够高，任何人都可以编写Python解释器来执行Python代码（当然难度很大）。事实上，确实存在多种Python解释器。 当然我们也可以选择更加集成的环境，即使用IDE。 集成开发环境（Integrated Development Environment，简称IDE，也称为Integration Design Environment、Integration Debugging Environment）是一种辅助程序开发人员开发软件的应用软件，在开发工具内部就可以辅助编写源代码文本、并编译打包成为可用的程序，有些甚至可以设计图形接口。 IDE通常包括编程语言编辑器、自动构建工具、通常还包括调试器。有些IDE包含编译器／解释器，如微软的Microsoft Visual Studio，有些则不包含，如Eclipse、SharpDevelop等，这些IDE是通过调用第三方编译器来实现代码的编译工作的。 这里推荐两种IDE。 1，Anaconda 4.4 这也是我正在使用的IDE，集成了IPython，Jupyter Notebook，Spyder，以及会为你预先安装好数量丰富的第三方库。一般来说，数据分析、机器学习领域的程序员会非常喜欢Anaconda。conda还提供了一个指令来替代pip，从而实现灵活的包管理，并且可以灵活的使Python多版本共存。Anaconda下载地址：https://anaconda.org/ 当然对于Anaconda来说你也可以先装Anaconda再在里面装Python。同样，建议把Anaconda加入环境变量 add anaconda to PATH。 这是Anaconda Navigator的一个界面，右边是集成好了的常用Python库。个人非常推荐使用Anaconda。注意：在进行包管理的时候，Anaconda通常会加入清华的源。 2,PyCharm，专业Python IDE，饱受好评，JetBrains出品必属精品，非常适合专业开发。其专业版可以通过UESTC的学生邮箱来获得。请使用学生邮箱注册账号，获得免费的专业版。下载地址：https://www.jetbrains.com/pycharm/ 接下来我推荐一个美化插件：ConEmu，提供了一个cmd和powershell的更好看的前端：https://conemu.github.io/ 默认启动界面请选择cmd（Admin），相对来说比较好用。当然powershell（Admin）也是没问题的。 之后，我们开始我们的第一次编程。 Hello World！ 打开ConEmu： 输入python. 然后输入 1print("Hello World!") 如果一切正常，你将看到Hello World！从现在开始，你已经正式迈向了Python开发者的道路。 Tips： 1，Python3的print()是函数，而Python2的print 是指令。 2，Python解释器是逐行解释的，不会预先编译。 3，Python不区分单引号”和双引号””。 有什么参考书推荐吗？ 1，《Learn Python The Hard Way》，注意购买Python3版本。 2，《Python核心编程（第2版）》《Python基础教程（第2版·修订版）》 3，廖雪峰的Python3教程 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>张逸霄</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【MSC-2017企划】俱乐部会做什么活动呢？]]></title>
    <url>%2F2017%2F09%2F21%2F%E3%80%90MSC-2017%E4%BC%81%E5%88%92%E3%80%91%E4%BF%B1%E4%B9%90%E9%83%A8%E4%BC%9A%E5%81%9A%E4%BB%80%E4%B9%88%E6%B4%BB%E5%8A%A8%E5%91%A2%EF%BC%9F%2F</url>
    <content type="text"><![CDATA[微软学生俱乐部是是一个偏技术类的组织，兼顾了各个有趣的方向。 经费由MSRA直接提供，所以加入俱乐部是免费的，而且俱乐部承诺不会收钱。 对于0基础的萌新 1，新人技术培养计划 -C/C++方向（推荐给完全0基础的萌新，0基础到熟练玩耍C++） -C#方向（从0基础到Windows应用开发者） -Python方向（从0基础到Python玩家） Q：时间安排呢？ A：我们的技术培养会将主要精力放在线上，同时会有定期的线下讨论会。萌新可以选择自己方便的时候参与。 2，学术沙龙 -一起看看科技圈的最新消息，欢迎广大软粉参加讨论 -一小时科普活动，一小时入门计算机前沿领域 Q：什么是前沿领域？ A：比如机器学习，Web开发，网络安全之类的~ 3，图书奖学金计划 俱乐部成员可向俱乐部申请图书奖学金，用与学习某项计算机相关专业技术。当申请者认真读完该书，并且通过写博客或者开小型talk来证明已学到该书的知识之后，俱乐部将为其报销购书款项。由于事先我们签署过协议，这使得申请者更容易坚持把书认真读完，而不易半途而废。我们想达到的目的是激励俱乐成员进行学习，并且学有所成。 一些特别的活动 1，11月份，Hackathon 这是一场48小时的头脑风暴，俱乐部成员可以自由组队，参与黑客马拉松的思想热潮中。微软提供官方API和云计算平台，参赛队拥有专门的场地（可以通宵），享受俱乐部提供的餐食、小吃、饮料，享受开发的过程。参赛者可获得微软纪念T恤（视情况发放限定版）和奖金。 2，12月份，创新杯&amp;微软校园菁英计划 俱乐部将会展开宣传，组队报名参加微软创新杯。同时项目进入微软校园菁英计划，赢取去往MSRA夏令营的资格。 3，5月份，微软“编程之美” 俱乐部承担了编程之美比赛的宣传，也会组队进行比赛，领略微软的最新科技。 俱乐部内部的长期活动呢？ 俱乐部内部会有各个方向的讨论小组，今年已经定下来的小组有： -人工智能与机器学习小组 其他方向的小组正在筹划中。讨论小组目前决定采取定期线下碰头的形式，交流学术圈、科研圈的内容，同时会承担这个方向的入门任务。 还可以玩什么？ 1，12月份，编程一小时活动 我们将会和周边的中小学进行互动，走进课堂，用有趣的方式（比如微软提供编程小游戏）给小朋友一堂编程入门课。完成活动者可以获得证书。 2，PPT脑洞大赛（在筹） 3，成都软粉聚会（不定期） 福利 1，微软学生夏令营 每年8月份，俱乐部可以推选优秀部员免费去MSRA参与为期一周的夏令营。 查看往届部员的想法： https://www.zhihu.com/question/31743851 http://chuansong.me/n/2250686 2，在日常活动和年会上赢取微软纪念品 -活动限定T恤 -以及一系列神奇的礼物 3，加入MSP计划，赢取价值6W元的Visual Studio订阅 详见：https://msdn.microsoft.com/en-us/microsoftstudentpartners.aspx 俱乐部成员在申请MSP时将占巨大优势。电子科技大学这几年一共诞生了超过十名MSP。 微软校园精英面向全球，不仅仅是计算机专业的学生，推广他的学生项目，让当代学生站在科技的前沿，领略科技的魅力，更希望他们能于其中，利用微软的技术，一起去改善生活，改变世界。无论是微软亚洲研究院下30多所高校的微软学生俱乐部，亦或者是全球范围内的Microsoft Student Partner。 加入MSP，你将获得更加开阔的眼界、认识来自全国乃至各高校的优秀同龄人、还有每年价值上万美元的MSDN订阅。 ================================ document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });]]></content>
      <categories>
        <category>管理层公告</category>
      </categories>
      <tags>
        <tag>张逸霄</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【谷哥的新人技术培养计划】从最简单的开始]]></title>
    <url>%2F2017%2F07%2F28%2F%E3%80%90%E8%B0%B7%E5%93%A5%E7%9A%84%E6%96%B0%E4%BA%BA%E6%8A%80%E6%9C%AF%E5%9F%B9%E5%85%BB%E8%AE%A1%E5%88%92%E3%80%91%E4%BB%8E%E6%9C%80%E7%AE%80%E5%8D%95%E7%9A%84%E5%BC%80%E5%A7%8B%2F</url>
    <content type="text"><![CDATA[前言由于现在是假期，大家的时间比较好安排。所以大家比较可能会有时间系统地看书或者教程。教程从零到编写出第一个程序，方便大家自行安排学习。本次的作业是引导性的，需要学习了知识才能完成。希望大家在假期劳逸结合，学有所得，玩得开心！ C语言的前世今生 C是一种通用的编程语言，广泛用于系统软件与应用软件的开发。于1969年至1973年间，为了移植与开发UNIX操作系统，由丹尼斯·里奇与肯·汤普逊，以B语言为基础，在贝尔实验室设计、开发出来。C语言具有高效、灵活、功能丰富、表达力强和较高的可移植性等特点，在程序员中备受青睐，成为最近25年使用最为广泛的编程语言。目前，C语言编译器普遍存在于各种不同的操作系统中，例如Microsoft Windows, Mac OS X, Linux, Unix等。C语言的设计影响了众多后来的编程语言，例如C++、Objective-C、Java、C#等。二十世纪八十年代，为了避免各开发厂商用的C语言语法产生差异，由美国国家标准局为C语言订定了一套完整的国际标准语法，称为ANSI C，作为C语言的标准。二十世纪八十年代至今的有关程序开发工具，一般都支持匹配ANSI C的语法。–摘自 维基百科 术语解释编程语言：编写计算机程序的语言系统软件、应用软件：粗略的理解，系统软件指较为底层的软件，应用软件是面向使用者的软件操作系统：粗略的理解，操作系统是像Windows、Mac OS这样不同的平台。实际上操作系统也是一种程序，它负责管理各种计算机硬件与软件资源，是计算机系统的基石。B语言：一种被遗弃的编程语言，C语言的前身软件的可移植性：软件的移植指一个软件从一个平台迁移到另一个平台，比如一个手游从安卓系统迁移到苹果的IOS系统编译器：编译器是把程序代码转化成计算机程序的组件中的一个 为什么学习C语言？http://c.biancheng.net/cpp/html/2709.html 张逸霄注：我认为，C语言在现在固然有它的不足，在设计上也有些繁琐。在实际的工业界，C语言不是一门特别常用的语言。与之相对的，Python作为一门新生语言，拥有自己的灵活特性，的确很引人注目，而且的确很好学。 但是重点在于，语言越上层，你就看不到越底层的东西。如果你不学习C，你的编程思想会受到一些限制，你就可能被囚禁在高等语言的笼子里了。 第二个原因是，现在又很多主流语言，比如Java，C#，这些语言都是由C语言延伸过来的，C语言可以说是这些主流语言的简化版。当你将C语言学通了，再来看这些语言，你将会觉得它们好学得多。 另外，C语言的学习周期不长，一般来说一两个月你就能进入到中等水平，此时你就可以考虑学习C++了。 关于在线编程、WebIDE在线编程是为了方便学习与展示而发展出来的一种形式，由于为了安全起见，在线编程会有诸多限制，有的在线编程网站不支持输入，比如runoob的在线编辑器。 关于“Hello World”当新手开始学习、程序员使用一门新的编程语言时，编写的第一个程序通常是输出一行【hello, world】。一般来说，这是每一种计算机编程语言中最基本、最简单的程序，通常也会作为一般的编程语言教程的第一个程序。这个传统产生于贝尔实验室的技术文档中，后来广为流传，沿用至今。 张逸霄注：当然，某本著名的C语言书里使用的就是：“to C or not to C, that is a question.” Hello World代码分析1234567891011前置说明：程序代码中，/**/里面的内容是注释，是用来解释程序功能的文字解释，不会改变程序的行为。//在一行中，双斜杠后面的代码也是注释-----#include &lt;stdio.h&gt;int main(){ /* 我的第一个 C 程序 */ printf("Hello, World! \n"); return 0;} 顺序说明1.#include用来使用一个库中的功能stdio是C语言标准输入输出库下文的printf就是包含于这个库的。这一行代码表示程序使用C语言标准输入输出库中的内容也是大多数C语言程序都有的一行 2.空行没有任何作用，目的是使程序代码结构更清晰下面的缩进（每行代码前面相同数量的空格）作用也是如此 3.main()，主函数。是C语言程序开始的地方，跟随的一对花括号{}中的内容才是程序的主体。 4./**/里面是解释性文本 5.printf是C语言中输出内容最常用的函数，括号中的内容是要输出的东西。结尾的分号代表一条C语言语句的结束 6.return是返回的意思，通常代表一个过程的结束。return 0;是使程序结束的标准做法。 解析1.首先要说明的是，这个程序的主体只有printf(“Hello, World! \n”);一行代码，其余的部分是大多数C语言程序使用的固定格式。对于一个C语言程序，引入一个库的内容，写出程序入口是必要的。#号开头的一行代码（#include ）叫做预编译指令，预编译指令不是编程的主体，它控制编译器的行为。比如说这行指令告诉编译器，程序使用stdio.h库中的内容，如果不加这一行，那么printf函数是无法使用的，编译程序时会出现错误以上是include指令的使用，关于更多预编译指令的知识将在以后介绍 2.主函数main()前面的int在C语言中表示小整数（当然还有大整数，比如long和long long）函数前面的类型名称，表示的是函数返回的值，与结尾的return 0;相对应用int标记主函数的返回值类型，return 0;来结束程序是C语言程序的规范，事实上还存在其他写法，这里不做介绍。 张逸霄注：关于C语言的更多细节，可以参见两本著名的教材：《C Primer Plus（第六版 中文版）》以及《C语言程序设计现代方法》。前者是世界著名教材，后者是信软学院使用的教材，非常好用。 张逸霄注：另外，可以参见知乎链接：为什么学习C语言？ 在电脑中安装C语言集成开发环境(IDE)Dev C++安装教程：https://jingyan.baidu.com/article/948f5924014f72d80ff5f908.html顺便提一下，这个教程与实际操作的有些出入纯属正常，因为可能你使用的版本不一样。推荐使用英文的程序环境，中文也可以。后面的说明以英文为例 张逸霄注：当然你也可以使用Visual Studio 2017，相关配置方法参见知乎链接：怎么用Visual Studio写C语言？ 编写属于你自己的第一个程序打开Dev c++，从顶部的菜单栏中的File&gt;New&gt;Project…新建一个工程工程类型Basic&gt;Empty Project&gt;C Project项目名改为helloworld，点击下一步。这里的项目名可以理解为程序的名字选择一个空的文件夹来容纳项目，免得把电脑弄得乱七八糟 项目建立成功后会自动新建一个文件，亲手把一下内容输入： 123456#include&lt;stdio.h&gt;int main(){ printf("hello, world\n"); return 0;} 提示：缩进可以用键盘最左边的Tab键输入，Dev c++也有自动缩进、自动补全的功能（亲手写了上面的程序肯定能理解是什么意思） 写完按Ctrl+S保存文件，在相同的目录下保存刚刚写的代码，名字可以随便起。命名为main.c是标准的做法。按F9编译并且执行程序。（F9是上部工具栏中某个图标的快捷键，你可以去找一找） 等待一小会，弹出一个黑色窗体，里面有白色文字： 12345hello, worldProcess exited normally.Press any key to continue . . . 你的第一个程序至此运行完毕。 相关解释1.Dev c++是C语言和C++的IDE（集成开发环境）2.Dev c++最顶部的文字菜单叫菜单栏（Menu Bar），菜单中有Dev c++的功能与设置有图标的一条叫做工具栏（Tool Bar），工具栏上面是程序最常用的功能其他部分请自行摸索。 如果要在关闭Dev c++后，再次打开之前的项目：菜单栏中File&gt;Open…找到之前保存项目的文件夹，打开名字为【项目名称.dev】的文件即可(这次是helloworld.dev)— 注：上面的教程只是介绍了C语言，带你编写了第一个C语言程序。作业的难度不是很大，请查阅相关资料后完成。 作业1.程序示例： 123456789#include&lt;stdio.h&gt;int main(){ int a,b; printf("Input two number,divided with a space:"); scanf("%d%d",&amp;a,&amp;b); printf("The sum of them is:%d\n",a+b); return 0;} 这个程序展示了printf，scanf这两个函数的通常用法。请在runoob、C语言中文网、《C Primer Plus》或者在百度上上查阅变量，语句，操作符，转义字符，printf，scanf的知识来理解上面的程序。上面程序的功能是输入两个数字，输出它们的和。并且在运行的时候对用户要进行什么操作给予了提示，对输出做了说明，这是个好习惯。1)编写一个程序，输入三个数字，输出他们的积。例如：输入了2.5 3 4，输出30注意上面的数字是小数，不能用int储存 2)编写一个程序，输入三个数字，倒序输出他们。例如：输入了2 3 4，输出4 3 2 —（下面的两个并不是很简单哦）3)编写一个程序，输入一个英文的名字，输出打招呼。例如：输入Henry，输出Hello, Henry. 4)编写一个程序，输入一个一元二次方程的三个参数，输出两个根（假设有实根）。 张逸霄注：使用Visual Sudio写程序的时候，会有一个安全警告提示你：scanf()并不安全，你可以自行搜索解决办法，简而言之就是调整Visual Studio的安全等级。 2.程序实例： 12345678910111213141516#include&lt;stdio.h&gt;int main(){ int a; printf("Give me some money for my lunch:"); scanf("%d",&amp;a); if(a&lt;=50) { printf("You are too mean!"); }else if(a&lt;=100){ printf("Thank you!"); }else{ printf("I like you so much!"); } return 0;} 上面的程序是展示了分支型控制流的基本用法请在runoob、C语言中文网、《c primer plus》或者在百度上上查阅关于if语句的知识来理解上面的程序。并且了解while,do while,for,break,continue等关键字的用法。 1)写一个能一直计算两个数的和的程序，（算完一次提示是否继续） 2)写一个猜数游戏，玩家输入数字，系统提示是大了还是小了，猜对了结束，数字可以是固定的 3)写一个完善的解二元一次方程的程序（判断是否有根，有实根输出实根，没有输出虚根） 结尾 以上的作业涉及了C语言入门的各种知识，请同学们认真对待，不懂就查资料，靠自己的力量完成，注意培养自己的自学能力，不要轻易的问别人。但是有什么疑惑不解的难题时，不要不好意思，一定要找其他的同学或者学长问问。最后，如果我的教程有问题可以私发我，或者在大群指出，都可以的。 鉴于是假期，作业是不收的，想让我看可以私发我QQ或者QQ邮箱。 正式的教程在开学后发布，在此之间这篇教程可能会有所修改（更正文字错误，添加新内容）。我相信，半个月的时间，即使对于没有任何基础的同学来讲，看懂这些也是足够了。 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });]]></content>
      <categories>
        <category>C/C++</category>
      </categories>
      <tags>
        <tag>张逸霄</tag>
        <tag>谷亚奇</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[新的主席团成立！！]]></title>
    <url>%2F2017%2F06%2F03%2F%E6%96%B0%E7%9A%84%E4%B8%BB%E5%B8%AD%E5%9B%A2%E6%88%90%E7%AB%8B%EF%BC%81%EF%BC%81%2F</url>
    <content type="text"><![CDATA[今年的主席团换届完毕，感谢离开的学长们的付出😭。你们不在，我们还会继续前进！ 主席团换届结果： 主席 张逸霄 理事 谷亚奇 李沐瑾 技术部部长 王子和 运营部部长 任仕贤 产品部部长 王志伟 大家在新的一年齐心协力，共创佳绩！ 另外，官网开放了评论功能，大家的评论不会受限了！ document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });]]></content>
      <categories>
        <category>管理层公告</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[换届了！！！]]></title>
    <url>%2F2017%2F06%2F02%2F%E6%8D%A2%E5%B1%8A%E4%BA%86%EF%BC%81%EF%BC%81%EF%BC%81%2F</url>
    <content type="text"><![CDATA[The following is who keep the club running said: 谁终将声震人间，必长久深自缄默；谁终将点燃闪电，必长久如云漂泊。本周五中午13:00，俱乐部新一年主席团换届将拉开帷幕。 本次换届空缺出来的职位：理事x1 技术部部长x1 产品部部长x1 运营部部长x1（随实际情况可能增多或减少）主席团是俱乐部真正的核心，共同决定俱乐部的发展方向，策划活动；各个部长又有足够多的自主权，每一个部长都是本部门发展的最大BOSS。理事适合于多面手，协助各个部门的事务。各位如想在俱乐部的新一年中，与我们共同策划俱乐部的路途与走向，和其他主席团成员共同工作，此时便是加入的好时候。主席团成员各司其职，又会定期召开会议，共同讨论俱乐部事务。加入主席团并不需要耗费多少精力，同事们也会帮助你发展自己的计划。在承担主席团义务的同时，成员将能优先获得俱乐部总部各种福利（包括夏令营名额，和内推机会），诚邀各位加入！选拔的重要指标是俱乐部成员的投票，用你的热情去征服大家吧！另：如无特殊情况，俱乐部成员需要按时参加现场换届 The following is who write the page said: 你们谁还对我们俱乐部有所留恋的，就留下来吧！秋招之后我们就更新了，以我搞事的能力为名义担保，我们俱乐部一定会变得不一样🐳 ps:一定要来竞选！ document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });]]></content>
      <categories>
        <category>管理层公告</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[【Bot Framework完全攻略】2-2.蓝图（Bot Framework项目结构）]]></title>
    <url>%2F2017%2F04%2F30%2F2-2.%E8%93%9D%E5%9B%BE%2F</url>
    <content type="text"><![CDATA[当你导入Bot Framework项目时，你就看到了一大堆东西。这节教程我们就从Bot Framework项目的解决方案管理器出发，来讲讲项目中代码之外的一切东西。 首先你要知道Bot是一个基于ASP.NET的网络应用，它有一个固有格式，不是所有东西都需要做修改的。下面我先列出你能看到的所有东西的用途： Connected Services：从Visual Studio直接连接微软的一些服务（我们应该用不到这些高级的东西） Properties中的Assembly.cs：项目信息（用不到） *引用：右键点击引用可以管理引用和Nuget程序包，Nuget默认开启了你缺什么包就自动下载的功能，但是就像我之前提到的，使用一些功能时需要手动添加引用。 App_Start中的WebApiConfig.cs：Api配置（用不到） *Controllers中的MessagesController.cs *Dialogs中的RootDialog.cs **default.htm：Bot的首页，已经被我们修改成了与Bot对话的地方 Global.asax：响应网络应用的应用级和模块级事件（太高级以至于用不到） packages.config：文本方式管理应用程序使用的包（你不摸它可以包你没事） **Web.config：网络应用的配置信息，比如我们之前就把AppID和AppSecret加了进去，但是之后我们也用不到它了 所有用到过的东西我都打了“*”，其他的东西基本是不需要你改的（摸坏了后果自负）。 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });]]></content>
      <categories>
        <category>Bot Framework</category>
      </categories>
      <tags>
        <tag>谷亚奇</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【Bot Framework完全攻略】2-2.模具（C#项目结构）]]></title>
    <url>%2F2017%2F04%2F30%2F2-2.%E6%A8%A1%E5%85%B7%2F</url>
    <content type="text"><![CDATA[在着手准备打造天气娘之前我先讲一讲C#的项目结构。即使你学过编程（C/C++），你要知道C#只是名字和语言风格和他们有些相像而已。我不会费太多话讲他们的区别，我就挑一些关键的，你必须知道的东西。 首先，打开VS，新建一个C#控制台项目。看看你的解决方案管理器里面都有什么。 不出意外，在默认的解决方案下有一个同名的项目。项目包含依赖项和一个Program.cs 其中Program.cs是输出Helloworld的代码。上面的依赖项是做什么的呢？展开！ 好多好多东西。。。你如果只学过C/C++很基础的一部分，根据你的编程经验可能不是很懂。我们对比一下C++/C#的Helloworld程序代码。你只需要关注最上面的两行（1~2行） C# C++ 这两段程序的using那行都是用来声明使用的namespace（命名空间）的。但是C++上面还有预处理指令#include C#的在哪里呢？ 当然是在依赖项里啊（要不我费那么多话要干嘛。。） 我不在往下讲更多，讲的这些只是想让你注意一件事。 你想使用C#自带的库中的功能时，通常只需要加上像using System.xxx;这样的语句。那是因为.NET CORE这个库里面的东西实在是太多了，你在前面也看见了，就像C++里有一个变态的叫bits/stdc++.h的头文件一样。 但是，这个最基本的库并不具有整个计算机World所有的功能。For Example： 当你想使用C#去查询天气，你需要使用网络请求。这时候你去百度，找到一段代码，贴进来发现有些类是未定义的。比如说有个类叫HttpClient，根据往常的经验，这时候你去msdn或者其他的地方查到了这个类属于System.Net.Http命名空间，然后你在你程序的开头加入了一行using语句，发现提示你这个命名空间是不存在的。 这时候你要注意了，你犯的错误就像在C++中using namespace std 但是却没有#include一样 不用我说你可能也知道了，到依赖项/引用（在引用过一些其他的包后这个名字就变成了引用）那里，右键点击引用&gt;添加引用： 在弹出的包管理器中&gt;程序集&gt;框架 中，找到System.Net.Http并且勾选： 确认之后发现问题就解决了。 总结：这篇教程并没有带你做一些实际的东西，只是为了让你了解一下C#项目与C++或者其他语言不一样的地方，便于以后处理一些小问题。 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });]]></content>
      <categories>
        <category>Bot Framework</category>
      </categories>
      <tags>
        <tag>谷亚奇</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【Bot Framework完全攻略】2-1.天气娘（查询天气的Bot）]]></title>
    <url>%2F2017%2F04%2F29%2F2-1.%E5%A4%A9%E6%B0%94%E5%A8%98%2F</url>
    <content type="text"><![CDATA[作为我们的第一个实战项目，选择做一个查询天气的Bot是再好不过的了。（你问我为什么？简单呗~咳咳，呸！肯定是实用 啊。。） 注意：在后续的教程里，一个传送门我只开一次。大家感觉重要可以收藏好，或者下次再用的时候回来找或者自己到百度，谷歌搜。 还有一个非常重要的事，请大家到LUIS的官网登陆一下，因为用户第一次使用LUIS时，官方的服务器会花好长的时间创建用户的工作空间（原因大概是这样） LUIS：www.luis.ai/ 最后，我们天气娘的教程大概分这么几个部分： C#项目结构 Bot的项目结构 LUIS的食用方法 C#解析json的方法 完结篇 我们的教程并不是以连贯的形式来进行的，毕竟对于初学者，总是不喜欢看着一堆自己看不懂的东西。但是最后我们一定会把所有的东西集合到一起，拼出我们可爱的天气娘~ document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });]]></content>
      <categories>
        <category>Bot Framework</category>
      </categories>
      <tags>
        <tag>谷亚奇</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【Bot Framework完全攻略】1-10.Cheers!（初级篇总结）]]></title>
    <url>%2F2017%2F04%2F29%2F1-10.Cheers%2F</url>
    <content type="text"><![CDATA[读完了我写的初级篇教程，你也真是不容易。不过我在这里祝贺你，你已经知道了Bot开发的基本流程。这虽然没有啥好得瑟（炫耀）的，但是我觉的你可以开心一小下。 初级教程只是Bot开发的门票罢了，要想真正做出能用的，实用的，甚至于做出你可以用来得瑟（炫耀）一把的东西，你还要继续学习！ 现在，你可以选择去Bot的官网看官网文档（佐以谷歌翻译食用风味更佳）。这次传送门就不开了。我相信进去这么多次的网站你肯定收藏了或者记住网址了，对不对！（不对那你很棒哦） 最后提醒一次看官方Doc的同学，其实官网的Doc因为Bot Framework 的更新出现了许多小错误，富有C#使用经验的程序员通常可以简单的改正。但是，呵呵，呵呵，呵呵呵呵。 接下来的教程中，我们会共同开发一个用来查询天气的Bot。通过这个具体的例子，你肯定可以熟悉Bot开发的方方面面。（如果你想做一个查询xxx的也可以哦） 咳咳！就到这里。 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });]]></content>
      <categories>
        <category>Bot Framework</category>
      </categories>
      <tags>
        <tag>谷亚奇</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【Bot Framework完全攻略】1-9.给别人看看我们的航母（如何让别人用我们的Bot）]]></title>
    <url>%2F2017%2F04%2F29%2F1-9.%E7%BB%99%E5%88%AB%E4%BA%BA%E7%9C%8B%E7%9C%8B%E6%88%91%E4%BB%AC%E7%9A%84%E8%88%AA%E6%AF%8D%2F</url>
    <content type="text"><![CDATA[这篇教程就是Bot Framework系列教程初阶部分的最后一篇，读完之后，Bot开发全部的基本流程你应该就一清二楚了。（这可是后面的基础啊） 这次我就只告诉你Web Chat的使用方法，毕竟Bot支持的那些聊天平台（Skype什么的你室友有几个在用？）在国内使用的太少了。虽然说DirectLine这个功能可以把Bot连到微信公众号，不过那个比较不好弄，是我们后面课程的内容。 首先去Bot官网，并且登陆，进入My bots，选择你的Bot 找到Web Chat 后面的Edit： 点击之后进入Web Chat 的配置界面。第一次进入可能会提示你新建一个site如果没有的话，就点击左边的Add new site。site的名字随便起，没卵用的。然后进入这个界面： 你可以看到Secret keys （密钥）是隐藏的，点击后面的Show就能看到。 下面的Embed code（嵌入代码）是一段HTML代码，内容就是与你Bot聊天的聊天室。 打开你的记事本，把Embed code（嵌入代码）复制进去，然后复制Secret keys（密钥）其中的一个，替换掉记事本里的 YOUR_SECRET_HERE。这样你就得到一段可用的html代码。 接下来，打开你的VS，进入你的项目，到解决方案管理器中找到default.htm文件： 打开它，把body标签里面的内容替换成你记事本里的那段代码： 然后，保存你的更改。重新发布你的Bot，这样就可以通过直接访问Bot的主页（endpoint的网址去掉后面/api/messages）来直接访问Bot了。 效果图： 你会发现聊天的窗口太矮了。。。 在default.htm做出如下的修改可以改变小窗口的高度： 修改完记得保存，重新发布。 记得Web Chat的网址就是你发布的站点URL（你在发布页面能找到） 大功告成！你可以把聊天窗口的网址发给你的朋友们，让他们感受一下你在做的工作。 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });]]></content>
      <categories>
        <category>Bot Framework</category>
      </categories>
      <tags>
        <tag>谷亚奇</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【Bot Framework完全攻略】666-1.将Bot发布至Azure云（困难度I）]]></title>
    <url>%2F2017%2F04%2F24%2F666-1.%E5%B0%86Bot%E5%8F%91%E5%B8%83%E8%87%B3Azure%E4%BA%91%2F</url>
    <content type="text"><![CDATA[把Bot发送到Azure云上是最简单方便的选择了，而且Azure云有个学生免费的许可，是专门用来搭载像Bot这样的网络应用的。学生免费请注意！！！ 我还没说怎么发布你的项目0.0，不过在这之前我先带你申请一个那个学生免费的许可。Dreamspark传送门：www.dreamspark.com/ 首先你得用自己的Microsoft账号登陆（网页右上角）。 然后点击Account，进入账户设置： 然后你首先要完善个人信息。。。 然后就会进入真的Account页面。。。： 页面左下角的Get Azure就是获取免费Azure的地方，点击Active Azure，你会看到如下的东西： 红框中的 Register now是灰的，也就是说我们现在不能马上就申请，因为我们还没进行学生认证。下面蓝色的链接就是认证的链接。 点击之后，会提示你选择认证方式。偷偷告诉你，学校邮箱（School email address）最稳妥。。。： 然后你就输入你的学校邮箱，Micorsoft会给你的邮箱发邮件，就像一般的注册游戏账号的认证过程一样。。。。。讨厌死了手动复制链接地址： 不出意外的话链接会跳转到Account页面，此时Register now还是黑的，还需要点击下面蓝色的链接，然后才能完成验证（点击Continue）： 回到Account界面的你发现Register now还是灰的。。。。不过其实已经可以点进去了（仔细一点看你会发现字变成黑色了） 之后就进入了Azure云的登陆页面（不得不说画风突变） 登陆之后会有一些简单的设置 如果遇到下面的问题，就把国家改成美国。。。 之后又是简单的填写个人信息，协议条款。 填写完之后Azure会开始在服务器部署你的工作空间。趁着这个时候，泡杯柠檬茶(੭ु•́ω•̀)੭ु 开始使用免费的Azure喽！！！ 看到Azure丰富等功能了没。感觉兴奋的同学你别高兴的太早，感觉复杂的同学你也不要嫌烦，点击左上角的新建，看看你可以新建什么。 看完之后你的表情：(→_→) 只有这一个能用啊。。。（免费给你用就不错了好吗）： 既然就有这个能用，你就新建一个用用看： 填完东西，点创建就好。。。 Azure会开始部署你的Web App，不过这些你都不用管了，因为我们也用不到了。刚刚新建一个网络应用的目的其实是顺便创建一个新的资源组以及，，，让你感受一下微软的学生认证免费版的。。。。（我不说，你也别猜） 把网页全都关了（别关我这个教程），打开你的VS，进入你的项目。 这样点击发布： 或者这样： 进入发布页面，发布目标当然是Azure云，然后下面的新建/选择现有的选项也不用动，因为我们是第一次发布。 点击确定就可以了。 在创建App Service的界面，如果你的表单保持一片空白不能更改，那不是你的错。。。全都关了，喝完柠檬茶在打开吧（玄学问题 重启就好）。 表单自动填写完毕就可以点击创建。创建好了应该会自动发布吧，不会的话你就再发布一次。 如果发布失败了可以百度，谷歌，问学长 成功了的话，蓝色的网址就是bot的那个什么了。。。。（你懂就行）： 发布成功，你的Bot就被怼上了你的Azure。 最后注意下endpoint： 我的那个什么是 http://botapplication220170429091745.azurewebsites.net/ 那么endpoint就在后面加上api/messages 即 http://botapplication220170429091745.azurewebsites.net/api/messages 大功告成！ document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });]]></content>
      <categories>
        <category>Bot Framework</category>
      </categories>
      <tags>
        <tag>谷亚奇</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【Bot Framework完全攻略】1-8.把旗子插在船上（关联配置）]]></title>
    <url>%2F2017%2F04%2F24%2F1-8.%E6%8A%8A%E6%97%97%E5%AD%90%E6%8F%92%E5%9C%A8%E8%88%B9%E4%B8%8A%2F</url>
    <content type="text"><![CDATA[关联配置其实也很简单，但是在这之前首先你要有一个服务器来搭载你的Bot服务 传送门列表： 将Bot发布至Azure云（困难度I） 将Bot发布至本地服务器（困难度II） 将Bot发布之远程服务器（困难度III） 在搭建好服务器之后， 把https://your_bots_hostname/api/messages 中间的your_bots_hostname替换成你获得的服务地址，这些都应当是你在发布过程中配置好的 在本地的Bot项目中 通过解决方案管理器找到Web.config，找到如下部分并填写。要填的东西就是之前我告诉你妥善保管好的App ID还有密钥 填写完之后保存，并且重新发布到你的服务器。。。 在Bot官网中进入My bots，选择你要配置的Bot，之后再你看到的面板中点击这里： 之后找到这里，输入你的endpoint： 最后保存配置 回到那个总览的面板，下方有测试连接的按钮 如果你的所有东西都配置好了，看到的应该和我的不一样。。。 好吧我折腾了一小会，当你把一切都配置完了，并且测试成功应该是这样的： 至此，简单的开发流程你应该已经了解了。 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });]]></content>
      <categories>
        <category>Bot Framework</category>
      </categories>
      <tags>
        <tag>谷亚奇</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【Bot Framework完全攻略】1-7.向政府注册你的旗帜（注册一个你的Bot）]]></title>
    <url>%2F2017%2F04%2F24%2F1-7.%E5%90%91%E6%94%BF%E5%BA%9C%E6%B3%A8%E5%86%8C%E4%BD%A0%E7%9A%84%E6%97%97%E5%B8%9C%2F</url>
    <content type="text"><![CDATA[上一篇文章中我们实现的本地的Bot搭建及测试，为了能让小伙伴们也能看一看我们的Bot，我们需要到Bot官网注册一个Bot，官网提供了一些丰富的能让小伙伴们与Bot交流的方式，最简单的就是在网页上聊天，还有Skye等等，通过复杂一点的实现，也可以将Bot连接至微信公众号。 这一节我们只做准备工作，就是到官网注册一个Bot，并且我会告诉你一些配置的用途 首先登陆Bot官网：https://dev.botframework.com/ 你会看到顶部有一个导航栏 Bot Framework PREVIEW 官网的Bot概述 My Bots 管理你注册过的Bot Register a bot 注册一个新的Bot Documentaton 官方开发文档，佐以谷歌翻译食用风味更佳 Bot Directory 一个有趣的地方，有好多别人的Bot，更有趣的是你还可以用它们 Blog 官网的信息发布博客，如果你将来成为了一名高级的开发者，可以关注一下 初来乍到你可以逛逛 现在我们就来注册第一个Bot。进入Register a bot（登录过程跳过）: Name：Bot的名字 ，这个名字只有你把你的Bot公布到Directory才会被看到 Bot handle：你可以理解成ID，就像你在游戏中起的不能和别人重复的名字一样 Description：这个描述也是只有你把你的Bot公布到Directory才会被看到 Messaging endpoint：就是上一个教程中的endpoint，只不过这里肯定不能用localhost了，因为那是测试用的本地网址。这里暂且空下不填 App ID and password 部分：点那个蓝色按钮，微软会为你生成AppID还有密钥，你要妥善保管 Admin部分：Owners是主人。这个不用改，上面写的应该就是你的微软账号，如果想填多个账号用逗号分隔。下面的AppInsight xxxxxxxxxx是只有把你的Bot发布到Azure云时才会用到的，是一个用来分析请求的东西。 做好配置，勾选接受协议，点击Register注册。 至此你的Bot就注册完成了，你在My Bots那里应该就能找到了。 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });]]></content>
      <categories>
        <category>Bot Framework</category>
      </categories>
      <tags>
        <tag>谷亚奇</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【Bot Framework完全攻略】1-6.开始造船（写一个你的Bot项目）]]></title>
    <url>%2F2017%2F04%2F24%2F1-6.%E5%BC%80%E5%A7%8B%E9%80%A0%E8%88%B9%2F</url>
    <content type="text"><![CDATA[首先我们一起来导入模板。首先我可耻的说我用的是中文系统+中文VS+中文解说0.0 你如果还没下载模板文件，传送门附上：http://aka.ms/bf-bc-vstemplate Visual的项目文件，以及用户自定义模板默认位置都在 “用户的文件夹/文档”这一路径下，如果你用过更老的Windows，这里的位置应该叫我的文档0.0。呸！费了这么多话，也许一张图就能解决问题： 注意打开你对应版本的文件夹 比如我就要打开Visual Studio 2017（我也不知道为什么我会有一个2013。。。） 进入这个目录下的\Templates\ProjectTemplates文件夹，这是用户自定义模板的大本营 如果你看见了一个叫Visual C#的文件夹，那就把模板文件丢到里面，如果没有也没关系，直接放在根目录好像也行。 到这模板就导入完成了。 打开你的Visual Studio，新建一个项目，位置在顶部的 文件&gt;新建&gt;项目 在打开的窗口中 依次选择 模板&gt;C#&gt;Bot Application 点击确定 你就会看到如下场景： 左面的解决方案管理器中可以看到项目的所有文件，如果你没有看到解决方案管理器，他可能像工具箱一样在左面被折叠了起来 还是没有的话 到顶部菜单的 视图&gt;解决方案管理器 去打开 你可以顺便看看项目的结构（如果你看得懂） 接下来就可以开始本地调试（就是在本地测试一下你的Bot，先和自己做的Bot聊聊。。。） 点击上面的按钮或者按F5开始调试，之后你应该看到下面的窗口，或者类似的东西。（如果调试不成功，显示代码有错误，你可以等一等，因为Bot SDK正在后台自动下载） 读完上面的网页你会看到有个词叫endpoint，你可以暂时的把它理解成Bot服务的网址。上面网址localhost:3979就是本地调试的your_bots_hostname。所以开启调试后我的Bot的endpoint就是https://localhost:3979/api/messages你的应该和我的差不多，有的时候3979端口会被占用那么上面的网址给你的就是其它端口。 另外，在这里有一点需要注意，虽然在我们的认识中 localhost = 127.0.0.1 但是在这里是不能替换的，具体原因可以自行查阅相关资料。 接下来，你只需要打开你的模拟器了。如果你还没有，传送门：https://emulator.botframework.com/ 安装以后打开你的模拟器： 左边是聊天窗口，右边是控制台。在开始之前，点击聊天窗口顶部的Enter your endpoint URL 并且输入我们之前获得的endpoint: 注意，由于我们是本地测试，所以其他的一律不填，点击CONNECT继续，这时候你会发现控制台有了变化 POST 200代表发送数据成功，如果你看到了红色的文字，出现了错误，可以重启一下这个模拟器，可能会解决问题，如果出现了问题不能解决，可以到俱乐部的QQ群提出，也可以直接问学长（不要问我啦） 这个应该是一切就绪时你会看到的： 我对我的Bot说了句Hello。。。。 看得出Bot有了回应，控制台也有了变化，这就是一般Bot调试的流程，如果出错了，就分析控制台Log的内容。再次说明，看不懂的Log(日志)和其他的东西要问哦。 至此，一个你的基本的Bot就构建并测试完成了！ document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });]]></content>
      <categories>
        <category>Bot Framework</category>
      </categories>
      <tags>
        <tag>谷亚奇</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【Bot Framework完全攻略】1-5.小试牛刀]]></title>
    <url>%2F2017%2F04%2F24%2F%E3%80%90Bot%20Framework%E5%AE%8C%E5%85%A8%E6%94%BB%E7%95%A5%E3%80%911-5.%E5%B0%8F%E8%AF%95%E7%89%9B%E5%88%80%2F</url>
    <content type="text"><![CDATA[本篇教程将引导你实现一个最基础的Bot 开始造船（写一个你的Bot项目） 向政府注册你的旗帜（注册一个你的Bot） 把旗子插在船上（关联配置） document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });]]></content>
      <categories>
        <category>Bot Framework</category>
      </categories>
      <tags>
        <tag>谷亚奇</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【Bot Framework完全攻略】1-5.小试牛刀]]></title>
    <url>%2F2017%2F04%2F24%2F1-5.%E5%B0%8F%E8%AF%95%E7%89%9B%E5%88%80%2F</url>
    <content type="text"><![CDATA[本篇教程将引导你实现一个最基础的Bot 开始造船（写一个你的Bot项目） 向政府注册你的旗帜（注册一个你的Bot） 把旗子插在船上（关联配置） document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });]]></content>
      <categories>
        <category>Bot Framework</category>
      </categories>
      <tags>
        <tag>谷亚奇</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【Bot Framework完全攻略】1-4.战争前的准备]]></title>
    <url>%2F2017%2F04%2F23%2F1-4.%E6%88%98%E4%BA%89%E5%89%8D%E7%9A%84%E5%87%86%E5%A4%87%2F</url>
    <content type="text"><![CDATA[我们来聊聊写程序的部分。。。 官网为Bot Framework的开发者提供了两种SDK。不懂什么是SDK的，百度百科传送门：http://baike.baidu.com/link?url=bH9-2ES2i6OPUXNpunCTeGSyQcgatkabbUHuxMIGMZlQSRtIkOmLTXT3p5U_Dz5buT_52YyNtcLiYR71dKbtBa Bot Framework的开发可以用.NET SDK或者Node.js SDK来进行。 Node.js是用javascript写服务端的东西，我并不是很了解。我们的教程打算使用.NET SDK来进行（都是微软自己家的东西） 我们选用的开发语言是C#。虽然说.NET SDK是支持C++的，而且大多数人都会使用C++，但是使用C++开发的难度绝对不比从0开始学C#在开发要简单。简单来说，C++/CLR 要求你对C++有更到位的理解，并且会使用一些不属于C++的诡异语法。同时你要对C++环境下的托管编程有理解。 如果你要使用一些其他的开发方式，请参考 官方文档：https://docs.botframework.com/en-us/ 谷歌翻译：https://translate.google.cn 如果你选择了Node.js或者C++/CLR 慢走不送。。。 既然你到了这里，那么我开门见山的列出你需要的东西： Microsoft账号（这东西我想大多数人都有，不过还是要说一下） Visual Studio 2015 （大于均可，小于不知道）https://www.visualstudio.com/zh-hans/downloads/ Bot模板 （VS&amp;C#专用）http://aka.ms/bf-bc-vstemplate 一个服务器，可以是Azure云，也可以是其他的你自己的服务器（需要支持ASP.NET），如果没有我后面也会给你提供其他解决方案。 Bot Emulator（这个是官方提供的本地测试工具）https://emulator.botframework.com/ 有了这些东西就差不多了吧。。。 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });]]></content>
      <categories>
        <category>Bot Framework</category>
      </categories>
      <tags>
        <tag>谷亚奇</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【Bot Framework完全攻略】1-3.这东西是怎么干活的？]]></title>
    <url>%2F2017%2F04%2F23%2F1-3.%E8%BF%99%E4%B8%9C%E8%A5%BF%E6%98%AF%E6%80%8E%E4%B9%88%E5%B9%B2%E6%B4%BB%E7%9A%84%2F</url>
    <content type="text"><![CDATA[我不得不说，我写的前一篇文章很简陋。不过我也相信，这能让你对Bot有最直观的了解。而且我也会坚守这个道理，Simple is good！ 你要知道，如果不是我发布的，文章的标题可能叫一个其他的令人反感的名字。 步入正题！ 首先，我之前说过Bot是一个网络服务，最终要部署到服务器上的。想一想自动客服和人工客服的区别（除了服务器你还指望着谁来替你回复用户的消息） 接着，你需要到Bot Framework的官网上注册一个Bot。你如果问我为什么会有这一步。。。我就在这里勉为其难的解释一下，这样的设计是与Bot的一些其他的有趣的功能和特性有关系的。 你可以去Bot的官网的Bot Directory页面看看，或许你会明白一丢丢。。。传送门：https://bots.botframework.com/ 就这样，你只需要： 写程序并且发布到服务器（听不懂别着急） 到Bot官网注册一个Bot（后面讲别着急） 进行一些关联配置（面包和牛奶都会有的别着急，笑哭。。。） 这是最粗略的流程，详细怎么做，步步深入，请大家关注后续教程。 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });]]></content>
      <categories>
        <category>Bot Framework</category>
      </categories>
      <tags>
        <tag>谷亚奇</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【Bot Framework完全攻略】1-2.Bot简介]]></title>
    <url>%2F2017%2F04%2F23%2F1-2.Bot%E7%AE%80%E4%BB%8B%2F</url>
    <content type="text"><![CDATA[这是Bot Framework的官方文档：https://docs.botframework.com/en-us/ 不得不说全英文的东西还是很让人头疼的。如果你真的那么爱看官方的文档的话，这里附上谷歌翻译的链接：https://translate.google.cn/ 首先，我来介绍一下这个大家伙。官网上给出的概述往往并不是很直观。直观的额说，Bot Framework就是那种开发在线客服的东西。不要误会以为Bot是指像小冰一样的聊天机器人哦。Bot的具有更强的目的性，因此开发起来并不像想象中的那么困难。与此同时Bot也更加的实用。 下面给出官网的一个例子： 你应该能看懂上面的例子吧，这就是一个用来预订理发服务的Bot。 Bot Framework就是一个用来开发在线非人工服务的框架。并没有多么高深。主要的用途就像上面的例子展示的那样。但你所见的只是Bot极小的一部分功能，Bot所具有的更强大的功能与更丰富的交互方式，会在将来的教程中逐步讲解。 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });]]></content>
      <categories>
        <category>Bot Framework</category>
      </categories>
      <tags>
        <tag>谷亚奇</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【Bot Framework完全攻略】1-1.攻略说明]]></title>
    <url>%2F2017%2F04%2F23%2F1-1.%E6%94%BB%E7%95%A5%E8%AF%B4%E6%98%8E%2F</url>
    <content type="text"><![CDATA[大家是否对今年的编程之美比赛有所了解呢？ 如果你还不是很了解，那么，这里是官网传送门: http://studentclub.msra.cn/bop2017/ 建议你先去看一看 总结起来，这次比赛就是做一个足以介绍自己学校的Bot。。。我不得不说，这个不酷，不炫，甚至还有点无聊。。。但是这次比赛的目的性很强，如果你没用过Bot Framework 或者相关框架，在或者你没写过网络服务，在或者你没写过稍微大一丢丢的程序。。。可以来练一练手 ^_^||| 如果你是个新人，请慎重抱团。额。。。我是指团队合作方面的新人。有一个规则叫做1+1&lt;1，我没打错是小于1，不是小于2。不会团队合作的队友是会互相拖累的。不过，如果能找到值得信赖的好队友也是极好的。 由于Bot开发涉及的知识较多，而且官方并没有推出友好的中文文档，所以接下来的日子里，我会负责推出一系列的Bot Framework相关教程来帮助大家对Bot开发整体有充分的了解。特此声明，文章更新持续稳定。如有更新不及时，隔着屏幕你又打不死我 ╮(╯▽╰)╭。 非常感谢 –&lt;-&lt;@ document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });]]></content>
      <categories>
        <category>Bot Framework</category>
      </categories>
      <tags>
        <tag>谷亚奇</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【俱乐部活动】Bot Framework技术汇]]></title>
    <url>%2F2017%2F04%2F12%2FBotFramework%E6%8A%80%E6%9C%AF%E6%B1%87.md%2F</url>
    <content type="text"><![CDATA[4月，俱乐部进行了编程之美的专题技术沙龙，主题是Bot Framework的了解与使用。 副主席张逸霄主讲本次技术沙龙。 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });]]></content>
      <categories>
        <category>Bot Framework</category>
      </categories>
      <tags>
        <tag>张逸霄</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【俱乐部活动】2015年创新杯宣讲会]]></title>
    <url>%2F2015%2F12%2F03%2F%E3%80%90%E4%BF%B1%E4%B9%90%E9%83%A8%E6%B4%BB%E5%8A%A8%E3%80%912015%E5%B9%B4%E5%88%9B%E6%96%B0%E6%9D%AF%E5%AE%A3%E8%AE%B2%E4%BC%9A%2F</url>
    <content type="text"><![CDATA[2015年12月3日，电子科技大学微软学生俱乐部于立人楼B308举办了2015年创新杯宣讲会。微软成都的工作人员为在场的同学们激情讲述Azure云与2015年创新杯的报名流程。 图为微软技术人员讲述Azure云平台技术。 图为工作人员发放奖品。 图为散场之后同学仍然在于技术人员进行热烈讨论。 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });]]></content>
      <categories>
        <category>活动</category>
        <category>创新杯</category>
      </categories>
      <tags>
        <tag>张逸霄</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【俱乐部活动】2015年10月·黑客马拉松]]></title>
    <url>%2F2015%2F11%2F01%2F%E3%80%90%E4%BF%B1%E4%B9%90%E9%83%A8%E6%B4%BB%E5%8A%A8%E3%80%912015%E5%B9%B410%E6%9C%88%C2%B7%E9%BB%91%E5%AE%A2%E9%A9%AC%E6%8B%89%E6%9D%BE%2F</url>
    <content type="text"><![CDATA[2015年，微软学生俱乐部黑客马拉松启动仪式在四川大学举办。 电子科技大学微软学生俱乐部在2015年10月31日-2015年11月1日进行了为期48小时的黑客马拉松活动，有13组同学报名，展开了思维的头脑风暴。 图为黑客马拉松现场。 图为一组同学在进行项目展示。 本次活动由张帆等时任主席团成员组织，笔者（张逸霄）同样参与了活动的全程策划与实施。 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });]]></content>
      <categories>
        <category>活动</category>
        <category>Hackathon</category>
      </categories>
      <tags>
        <tag>张逸霄</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【俱乐部活动】俱乐部2015年秋季见面会]]></title>
    <url>%2F2015%2F10%2F10%2F%E3%80%90%E4%BF%B1%E4%B9%90%E9%83%A8%E6%B4%BB%E5%8A%A8%E3%80%91%E4%BF%B1%E4%B9%90%E9%83%A82015%E5%B9%B4%E7%A7%8B%E5%AD%A3%E8%A7%81%E9%9D%A2%E4%BC%9A%2F</url>
    <content type="text"><![CDATA[2015年10月9日晚7：00，成电微软俱乐部在品学楼A106举行了第一次见面会暨内建活动，旨在帮助俱乐部成员相互了解，增进友谊，从而提升整个俱乐部的凝聚力。 活动开始，首先由张帆主席讲话。主席提到，俱乐部是大家的俱乐部，大家要有主人翁精神。以俱乐部为平台，展示自己，锻炼自己，成就自己。随后主席与各个部门负责人进行了自我介绍，向大家分享了自己学习、活动的经历并且明确了各部门的职责。会上还请到了上届主席张明群向大家分享了自己三年俱乐部的经历，整个过程掌声雷动。 随后在财务部部长梁浩东的主持下，随机分为了5个小组，每个小组5—6人，每小组由一名部长带领，准备进行小组对抗。为了帮助大家更加熟悉俱乐部的其他成员，此次分组有意将同部门的人员错开，如此更方便大家跨部门交流。期间人力资源部部长夏雪还向各小组分发了零食与饮料，玩好也别忘了吃好呀。 小组分配完毕，各小组有10分钟的时间让成员间相互熟悉。一时，教室一片火爆，大家都聊得火热兴起。第五小组在部长马洪亮的带领下更是玩起了“名字接龙”的游戏，好生热闹。 1 第一个游戏：折飞机。每个小组用所给的A4纸折出三个纸飞机，从教室的最后方向讲台处试飞，若飞机飞至黑板的上、中、下，分别记4、3、2分。各小组有8分钟的制作和试飞时间。 在主持人梁浩东部长的开始令下，教室各种纸飞机已纷纷出厂试飞，一架架歼10、20、30翱翔天际。当然啦，那种技术不到家的自然是出师未捷身先死啦！不过也有技术过硬，赶英超美的，居然飞到了黑板的最上方，直击灯管！大家都叹为观止。直呼歼100就是牛 试飞之后，比赛正式开始，原本被看好的第三组出现了滑铁卢，歼100起飞过高，中途遭遇阻击，被天花板一掌拍下，真是可惜，而第五组凭借稳扎稳打的技术，拿到了两个2分，领跑积分榜。 2 第二个游戏：肢体传话。以小组为单位上台表演，第一个人从主持人处获得题板上的成词语，用肢体语言表演给第二个人，整个过程不能发出一点声音，也不能用口形，第二人再以同样的方法传递给第三个人，以此类推。 首先上场的是第五组，一个广场舞的表演，引爆全场，卓识让大家开了眼。随后第四组的挤公交表演也是蛮拼的，愣是将黑板比作了车窗，每传递一次，便撞击一次黑板，让人大呼过瘾。最让人沸腾的是第三组的上厕所的表演，一帮男生中偏偏夹带了个人力资源部部长夏雪（女），这样的场面怎能让人错过？手机的摄像头如饥似渴得捕捉着这样的饕餮盛宴。 3 第三个游戏：一元五角。（1）为充分表示重视会里的女性朋友，规定每个女生代表“一元”，每个男生代表“五角”。 （2）报名参加者一男一女分隔开围成一个大圆圈，组织者说开始，大家就手拉手围着圆圈走。（3）组织者大声说出一个金额，参加者在最短的时间内找到朋友抱在一起组成组织者要求的金额。例如：听到口令“二元五角”，可以的组合为：两个女生+一个男生；或五个男生；或一个女生+三个男生 没有找到朋友和组合数字不正确的遭到淘汰。（4）经过几轮，最后站在一起的一个小组获胜，获胜组人数控制在三至四人以内，也就是说如果超过这个人数还要加赛。胜利的2至3人获奖。 游戏的高潮出现在游戏中期，当人数只剩下一半的时候，主持人喊出了一块，此时，一场为争夺市场部马洪亮的战争打响了。这是两个男的为了另一个男的战争：紧抱，扭扯，摔倒，死不放手。一个堂堂八尺男儿，被人争夺……这画面太美，我不敢看。最后由第三组的三名成员留在舞台上而结束。原来他们早有预谋有木有！赢了的当然少不了奖品啦！ 本次活动充分调动了成员的激情与活力，加强了俱乐部成员的相互认识，融洽了俱乐部氛围，完成了”学在微软，玩在微软“的目标，这样的活动以后还会继续。 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });]]></content>
      <categories>
        <category>活动</category>
        <category>见面会</category>
      </categories>
      <tags>
        <tag>张逸霄</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【俱乐部活动】2015年俱乐部秋季招新]]></title>
    <url>%2F2015%2F09%2F22%2F%E3%80%90%E4%BF%B1%E4%B9%90%E9%83%A8%E6%B4%BB%E5%8A%A8%E3%80%912015%E5%B9%B4%E4%BF%B1%E4%B9%90%E9%83%A8%E7%A7%8B%E5%AD%A3%E6%8B%9B%E6%96%B0%2F</url>
    <content type="text"><![CDATA[为了帮助成电学子更好的了解微软，加入微软。2015年9月17日晚7：00，成电微软俱乐部在品学楼A102举行了招新宣讲会。 在大家期盼的眼神中，主持人开始了本次的招新宣讲会。首先，主持人介绍了出席本次宣讲会的张帆主席和各个部门的负责人，以及邀请到的嘉宾：上届主席张明群、副主席温尔雅。 在介绍完本次宣讲会的流程之后，张帆主席从俱乐部的目的、历史、夏令营体验三个方面向大家展示了微软。微软学生俱乐部（Microsoft Student Club，简称MSC），是微软亚洲研究院与高校合作培养人才的一种探索。2000年10月15日，第一个俱乐部在四川大学成立，至今全国已有32所高校拥有了自己的俱乐部，今年已是俱乐部成立的第15个年头。俱乐部本着“学习先进技术，开拓创新思维，体验多元文化，成就一流人才”的宗旨，培养会员的创新头脑、实践能力和组织能力。我们号召各个专业同学加入俱乐部，不一定必须是要计算机相关专业的，也不一定需要什么技术基础，我们会鼓励同学在俱乐部做自己感兴趣的项目，认识一些志同道合的朋友，通过想过活动来锻炼自己，提高自己，成就自己！ 接着，主席分享了自己夏令营的体验，主席说道：这次微软俱乐部成立15周年夏令营，有全国30多所知名高校以及香港台湾的同学参加。一共150个营员，在西安度过了非常难忘的5天（路费，吃住全部报销）。有令人热血沸腾的Hacker主题演讲，紧张激烈的Hackathon，还有精彩纷呈的15周年庆典晚会。更重要的是短短5天的时间，我们在一起团结，协作，奋进，拼搏，成为非常好的朋友。就这样的一群人，聚是一团火，散作漫天星。然后主席还预先回答了招新群中的问题。其中问的最多的问题就是成电微软俱乐部和其他的社团的什么区别：首先，俱乐部是微软亚洲研究院负责，而其他组织大部分是学校的老师或者同学，俱乐部成员可以通过俱乐部了解到公司的文化，接触到公司的员工和产品；不仅如此，俱乐部的氛围要比学生会更轻松，不会有太多任务性的工作，大家可以在俱乐部做自己喜欢的事，在快乐中锻炼自己，成就自己 过后的各部门介绍也是精彩万分，为了抢人，市场部部长提出市场部可以提着拍照的幌子把俱乐部所有的福利都享受到的论调吸引了不少同学。通过部门介绍，同学们知道了各部门的职责，明确了自己的具体兴趣所在。 张明群前主席还向同学们介绍了微软校园精英项目（MSP），MSP微软校园精英是微软公司针对在校学生在全球范围内所设立的项目。旨在鼓励那些在校园里积极倡导、推动创新实践，乐于积极帮助他人的优秀学生，给他们提供微软最前沿的技术资源，以及更广泛的交流、展示自我的平台。一般建议是大二大三或者保研的同学申报。 MSP福利多多，其中最令人映像深刻的要数前副主席温尔雅和大家分享的南京IC2014 localfinal 小记者、西雅图 IC2014 world wide final 小记者和北京 IC2015 local final 小记者体验，要知道这些涉及的金钱问题都是“财大气粗的微软大大”全包的！简直爽爆了有木有！ 最后的问答环节也是人气火爆，根本停不下来！张帆和温尔雅站在台上给大家解答各种问题真是棒棒哒！ 本次招新宣讲向大家展示了一个全面的微软俱乐部，向大家诠释了Hckathon精神以及MSP，真心感谢各位喜欢微软的小伙伴和两位主席的到来！ document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });]]></content>
      <categories>
        <category>活动</category>
        <category>招新</category>
      </categories>
      <tags>
        <tag>张逸霄</tag>
      </tags>
  </entry>
</search>
